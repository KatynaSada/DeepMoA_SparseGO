[
  {
    "objectID": "DeepMoA.html",
    "href": "DeepMoA.html",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "",
    "text": "import sys # we require code from other folders\nimport pandas as pd\nimport numpy as np\nimport itertools\nimport pickle\nimport os\nos.environ['KMP_DUPLICATE_LIB_OK']='True'\n\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nCB_color_cycle = ['#EECC16', '#62BB35', '#FDAE33','#208EA3', '#EA4E9D', '#984ea3','#999999', '#e41a1c', '#dede00']\n\n\nimport matplotlib.font_manager as fm\nfont_files = fm.findSystemFonts()\n\nplt.rcdefaults()\n# Go through and add each to Matplotlib's font cache.\nfor font_file in font_files:\n    fm.fontManager.addfont(font_file)\nplt.rc('font', family='Roboto')\n\n\nplt.rc('font', family='Roboto')\nplt.rcParams['font.family'] = 'sans-serif'\nplt.rcParams['font.sans-serif'] = 'Roboto'\n\n\n%config InlineBackend.figure_format='retina'\n\n\n# pytorch relates imports\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\n\n# imports from captum library\nfrom captum.attr import LayerDeepLift\n\n\n# for combobox\nfrom __future__ import print_function\nfrom ipywidgets import interact, interactive, fixed, interact_manual\nimport ipywidgets as widgets\n\n\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.io as pio\n\n\npd.options.display.min_rows = 20000\npd.set_option('max_colwidth', 200)\n\n\npd.options.display.max_rows = 20000\n\n\npd.set_option('min_rows', 20000)\n\n\nmac = \"/Users/katyna/Library/CloudStorage/OneDrive-Tecnun/\"\nwindows = \"C:/Users/ksada/OneDrive - Tecnun/\"\ncomputer = windows # CHANGE\n\n\nsys.path.append(computer + \"SparseGO_code/code\")\nimport util\nfrom util import *\n\n\n%matplotlib inline\n\n\n# To make histograms\ndef histogram(dataframe, color, title, ylabel,n_bins):\n    N, bins, patches = plt.hist(dataframe, color=color,bins=n_bins, linewidth=0.1)\n\n    for i in range(0,len(bins)-1):\n        if bins[i]<0.05:\n            patches[i].set_facecolor(CB_color_cycle[2])\n\n    plt.xlabel(\"P-value\", fontsize=16)  \n    plt.ylabel(ylabel, fontsize=16)\n    plt.title(title, fontsize=16)\n    plt.xticks(fontsize=14)  \n    plt.yticks(fontsize=14)\n    ax = plt.subplot(111)  \n    ax.spines[\"top\"].set_visible(False)  \n    ax.spines[\"right\"].set_visible(False)    \n\n\ninputdir = computer+\"SparseGO_code/data/train_sparseGO/allsamples/\" # CHANGE\ndir1=computer+\"Tesis/Codigo/VariableImportance/\"\ndir2=computer+\"SparseGO_code/results/weights&biases/SparseGO_Standard_Expression/samples1/\" # CHANGE\nresultsdir=dir2\n\n\ngene2id = inputdir+\"gene2ind.txt\"\ncell2id=inputdir+\"cell2ind.txt\"\ndrug2id=inputdir+\"drug2ind.txt\"\ndrug2fingerprint=inputdir+\"drug2fingerprint.txt\"\nload=resultsdir+\"last_model.pt\"\n\nonto = inputdir+\"sparseGO_ont.txt\"  # CHANGE \ngenotype=inputdir+\"cell2expression.txt\"  # CHANGE \n\nnum_neurons_per_GO = 6 # CHANGE"
  },
  {
    "objectID": "DeepMoA.html#go-terms-info",
    "href": "DeepMoA.html#go-terms-info",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "GO terms info",
    "text": "GO terms info\n\n# Go term names\ngene_ontology = pd.read_excel('all_go_terms_info.xlsx')\ngene_ontology = gene_ontology.drop_duplicates(subset=['id'])\n\nGet all layers’ GO term with the neuron number\n\nall_terms_ids = {}\nall_terms_names = {}\nall_layers_non_virtual = {} # store only terms that are part of the layer (remove virtual), those are the important attribuitions\nall_layers_non_virtual_names = {}\nnum_neurons_per_GO = 6\n\nfor layer_number in range(len(layer_connections)-1):\n    layer_pairs = layer_connections[layer_number] \n    \n    terms_ids = []\n    names = []\n    output_id = create_index(layer_pairs[:,0]) # first 6 neurons correspond to the term with key 0\n    # all_terms_ids IS CREATED IN THE SAME GO TERM ORDER IN WHICH THE CORRESPONDING NETWORK LAYER WAS CREATED (when calculating the XAI score, this lets us know which GO term it corresponds to).\n    for term in output_id.keys():\n        #name = gene_ontology.loc[gene_ontology['GO_term'] == term].to_numpy()[0,3].replace(\"_\",\" \").capitalize()\n        name = gene_ontology.loc[gene_ontology['id'] == term].to_numpy()[0,1].capitalize()\n        for i in range(1,num_neurons_per_GO+1): # vector que tiene GO:0000038_1, GO:0000038_2 ... GO:0000038_6 y asi luego concatenar con las attributions\n            terms_ids.append(term+\"_\"+str(i))\n            names.append(name+\" (\"+str(i)+\")\")\n    all_terms_ids[layer_number] = np.array(terms_ids)\n    all_terms_names[layer_number] = np.array(names)\n\n    non_virtual = [] # store the terms part of that layer\n    non_virtual_names = []\n    for term in level_list[layer_number+1]:\n        nv_name = gene_ontology.loc[gene_ontology['id'] == term].to_numpy()[0,1].capitalize()\n        for i in range(1,7):\n            non_virtual.append(term+\"_\"+str(i))\n            non_virtual_names.append(nv_name+\" (\"+str(i)+\")\")\n    all_layers_non_virtual[layer_number] = non_virtual\n    all_layers_non_virtual_names[layer_number] = non_virtual_names\n\nAll GO terms part of a layer (non-virtual) with their corresponding name and layer number…\n\nreal_go_info = pd.DataFrame({\"GO_term\":[],\"Name\":[],\"layer_number\":[]})\nfor layer_number in range(len(layer_connections)-1):\n    layer_go_info = pd.DataFrame({\"GO_term\":all_layers_non_virtual[layer_number],\"Name\":all_layers_non_virtual_names[layer_number],\"layer_number\":(layer_number)})\n    real_go_info = pd.concat((real_go_info,layer_go_info))\nreal_go_info.head()\n\n\n\n\n\n  \n    \n      \n      GO_term\n      Name\n      layer_number\n    \n  \n  \n    \n      0\n      GO:0006264_1\n      Mitochondrial dna replication (1)\n      0.0\n    \n    \n      1\n      GO:0006264_2\n      Mitochondrial dna replication (2)\n      0.0\n    \n    \n      2\n      GO:0006264_3\n      Mitochondrial dna replication (3)\n      0.0\n    \n    \n      3\n      GO:0006264_4\n      Mitochondrial dna replication (4)\n      0.0\n    \n    \n      4\n      GO:0006264_5\n      Mitochondrial dna replication (5)\n      0.0"
  },
  {
    "objectID": "DeepMoA.html#drugs-info",
    "href": "DeepMoA.html#drugs-info",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "Drugs info",
    "text": "Drugs info\n\ndef get_compound_names(file_name):\n    compounds = []\n\n    with open(file_name, 'r') as fi:\n        for line in fi:\n            tokens = line.strip().split('\\t')\n            compounds.append([tokens[1],tokens[2]])\n    return compounds\n\n\ndrugs = get_compound_names(inputdir+\"compound_names.txt\")\ndrugs.pop(0)\n\n['SMILE', 'Name']"
  },
  {
    "objectID": "DeepMoA.html#deeplift-for-vnn",
    "href": "DeepMoA.html#deeplift-for-vnn",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "DeepLIFT for VNN",
    "text": "DeepLIFT for VNN\nReference activation… (baseline)\n\nmedian_cell_features = np.median(cell_features,axis=0) # to use as a reference\nmedian_drug_features = np.genfromtxt(computer+\"SparseGO_code/data/glucose_fingerprint.txt\", delimiter=',')\n\n\nAttribution function: sum\n\ndef get_layer_attribution(layer_number,input_data,baseline,selected_drug_data):\n    dl = LayerDeepLift(model, model_layers[layer_number],multiply_by_inputs = True) # CHOOSE LAYER TO STUDY\n    dl_attr_test = dl.attribute(input_data,baseline)\n    dl_attr_test_sum = dl_attr_test.cpu().detach().numpy().sum(0) # the attributions are summed for each sample\n    \n    # all_terms_ids WAS CREATED IN THE SAME GO TERM ORDER IN WHICH THE CORRESPONDING NETWORK LAYER WAS CREATED (when calculating the XAI score, this lets us know which GO term it corresponds to).\n    attribution_data = pd.DataFrame(np.column_stack((all_terms_ids[layer_number],dl_attr_test_sum)), columns=[\"GO_term\",selected_drug_data[1]])\n    attribution_data[[selected_drug_data[1]]] = attribution_data[[selected_drug_data[1]]].apply(pd.to_numeric).round(10)\n    attribution_data = attribution_data.loc[attribution_data['GO_term'].isin(all_layers_non_virtual[layer_number])] # only the keep the non virtual terms\n    return attribution_data\n\n\n\nDeepLIFT for all drugs\n\nattribution_data_all = pd.DataFrame()\n# Obtain the top GO terms on all layers for each drug\nfor selected_drug_data in drugs:\n    selected_drug =selected_drug_data[0] # DRUG smile\n    selected_drug_features = []\n    drug_specific_features=drug_features[drug2id_mapping[selected_drug]] # features of drug\n    \n    for i in range(len(cell2id_mapping)): # make all combinations of selected_drug and cell types \n        selected_drug_features.append(np.concatenate((cell_features[i], drug_specific_features), axis=None))\n    selected_drug_features = torch.FloatTensor(np.array(selected_drug_features))\n\n    # Data for deeplift...\n    input_data = torch.autograd.Variable(selected_drug_features.cuda(0))\n    \n    # baseline is the median of the expression data and drug features \n    baseline = torch.FloatTensor(np.concatenate((median_cell_features, median_drug_features), axis=None))\n    baseline = torch.reshape(baseline, (1, baseline.size()[0]))\n    baseline = torch.autograd.Variable(baseline.cuda(0))\n    \n    attribution_data_drug = list(map(get_layer_attribution,range(0,len(model_layers)),itertools.repeat(input_data, len(model_layers)),itertools.repeat(baseline, len(model_layers)),itertools.repeat(selected_drug_data, len(model_layers)))) # get the attribution for each layer (map is similar to apply)\n    attribution_data_drug = pd.concat(attribution_data_drug) # concatenate attribution of all layers\n    \n    attribution_data_all = pd.concat([attribution_data_all,attribution_data_drug.iloc[:,1]], axis=1)\n    \n    print(selected_drug_data[1])\n    \nattribution_data_all = pd.concat([attribution_data_drug.iloc[:,0],attribution_data_all], axis=1)\n\n\nattribution_data_all = attribution_data_all.set_index(\"GO_term\")\n\n\nattribution_data_all.head()\n\n\n\n\n\n  \n    \n      \n      (-)-Parthenolide\n      (5Z)-7-Oxozeaenol\n      5-Fluorouracil\n      681640\n      A-443654\n      A-484954\n      A-770041\n      A-83-01\n      Acadesine\n      ACY-1215\n      ...\n      Vemurafenib\n      VER-155008\n      Vorapaxar\n      vorinostat:carboplatin (1:1 mol/mol)\n      vorinostat:navitoclax (4:1 mol/mol)\n      VU0155056\n      WZ4002\n      WZ8040\n      YL54\n      Zebularine\n    \n    \n      GO_term\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      GO:0000012_1\n      0.009143\n      0.012238\n      0.014801\n      0.008749\n      0.028462\n      0.002892\n      0.021746\n      0.003400\n      0.002582\n      0.015812\n      ...\n      0.010666\n      0.008861\n      0.014170\n      0.006866\n      0.016116\n      0.010692\n      0.023399\n      0.022375\n      0.010787\n      0.007544\n    \n    \n      GO:0000012_2\n      -0.000285\n      -0.000928\n      -0.000579\n      0.000208\n      -0.001000\n      -0.000165\n      -0.002064\n      -0.000199\n      -0.000089\n      -0.000651\n      ...\n      -0.001053\n      -0.000468\n      -0.000831\n      -0.000112\n      -0.000545\n      -0.000622\n      -0.001353\n      -0.001063\n      -0.000853\n      -0.000307\n    \n    \n      GO:0000012_3\n      0.000593\n      0.001505\n      0.003211\n      0.000860\n      0.002106\n      -0.000137\n      0.003661\n      -0.000340\n      -0.000157\n      0.002306\n      ...\n      0.000033\n      0.001873\n      -0.000379\n      0.001317\n      -0.000275\n      0.000724\n      0.003970\n      0.005052\n      -0.000554\n      0.000269\n    \n    \n      GO:0000012_4\n      -0.000407\n      -0.000310\n      -0.000145\n      -0.000331\n      -0.000294\n      -0.000306\n      -0.000686\n      -0.000259\n      -0.000302\n      -0.000689\n      ...\n      -0.000542\n      -0.000382\n      0.000087\n      -0.000564\n      -0.002327\n      -0.000219\n      0.000312\n      0.000633\n      -0.000277\n      -0.000085\n    \n    \n      GO:0000012_5\n      -0.000152\n      -0.000454\n      -0.000350\n      0.000121\n      -0.000196\n      -0.000090\n      -0.000926\n      -0.000056\n      -0.000057\n      -0.000293\n      ...\n      -0.000339\n      -0.000374\n      -0.000076\n      -0.000136\n      -0.000653\n      -0.000179\n      -0.000458\n      -0.000314\n      -0.000226\n      -0.000019\n    \n  \n\n5 rows × 790 columns"
  },
  {
    "objectID": "DeepMoA.html#cheml-ids",
    "href": "DeepMoA.html#cheml-ids",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "chEML IDs",
    "text": "chEML IDs\nGet chembl IDs of drugs if available (there are always 684 drugs, the compounds2ids object can be reused)\n\n# Get all chembl IDs -- takes long \nmolecule = new_client.molecule\n\ncompounds2ids = {}\nfor i,drug in enumerate(names):\n    \n    if \" + \" in drug:\n        drug_split = drug.split(\" + \", 1)\n        ID1 = list(molecule.filter(pref_name__iexact=drug_split[0]).only('molecule_chembl_id'))\n        ID2 = list(molecule.filter(pref_name__iexact=drug_split[1]).only('molecule_chembl_id'))\n        if len(ID1)>0 and len(ID2)>0:\n            compounds2ids[drug]=[ID1[0]['molecule_chembl_id'],ID2[0]['molecule_chembl_id']]\n        elif len(ID1)>0:\n            compounds2ids[drug]=ID1[0]['molecule_chembl_id'] \n        elif len(ID2)>0:\n            compounds2ids[drug]=ID2[0]['molecule_chembl_id'] \n        else:\n            print(drug,i)\n    \n    elif \":\" in drug: # combinations\n        drug_split = drug.split(\":\", 1)\n        ID1 = list(molecule.filter(pref_name__iexact=drug_split[0]).only('molecule_chembl_id'))\n        ID2 = list(molecule.filter(pref_name__iexact=drug_split[1].split(\" (\", 1)[0]).only('molecule_chembl_id'))\n        if len(ID1)>0 and len(ID2)>0:\n            compounds2ids[drug]=[ID1[0]['molecule_chembl_id'],ID2[0]['molecule_chembl_id']]\n        elif len(ID1)>0:\n            compounds2ids[drug]=ID1[0]['molecule_chembl_id'] \n        elif len(ID2)>0:\n            compounds2ids[drug]=ID2[0]['molecule_chembl_id'] \n        else:\n            print(drug,i)\n\n    else:\n        ID = list(molecule.filter(pref_name__iexact=drug).only('molecule_chembl_id'))\n        if len(ID)>0:\n            ID = ID[0]['molecule_chembl_id']\n            compounds2ids[drug]=ID\n        else:\n            # for drugs that have the chembl ID as the name!!\n            ID = list(molecule.filter(chembl_id=drug).only('molecule_chembl_id')) \n            if len(ID)>0:\n                ID = ID[0]['molecule_chembl_id']\n                compounds2ids[drug]=ID\n            else:\n                # in case it is not found by pref_name\n                ID = list(molecule.filter(molecule_synonyms__molecule_synonym__iexact=drug).only('molecule_chembl_id'))\n                if len(ID)>0:\n                    ID = ID[0]['molecule_chembl_id']\n                    compounds2ids[drug]=ID\n                else:\n                    print(drug,i)\n\n\n# for CTRPv2 and GDSC2\ncompounds2ids[\"(-)-parthenolide\"]=\"CHEMBL540445\"\ncompounds2ids[\"bleomycin a2\"]=\"CHEMBL403664\"\ncompounds2ids[\"blebbistatin\"]=\"CHEMBL1328324\"\ncompounds2ids[\"bax channel blocker\"]=\"CHEMBL1402326\"\ncompounds2ids[\"am-580\"]=\"CHEMBL69367\"\ncompounds2ids[\"bibr-1532\"]=\"CHEMBL27323\"\ncompounds2ids[\"cyanoquinoline 11\"]=\"CHEMBL436817\"\ncompounds2ids[\"etp-46464\"]=\"CHEMBL3334621\"\ncompounds2ids[\"importazole\"]=\"CHEMBL1498173\"\ncompounds2ids[\"isoevodiamine\"]=\"CHEMBL81925\"\ncompounds2ids[\"aminofurazanyl-azabenzimidazole 6n\"]=\"CHEMBL220241\"\ncompounds2ids[\"bms-345541 free base\"]=\"CHEMBL249697\"\ncompounds2ids[\"mim1\"]=\"CHEMBL3265288\"\ncompounds2ids[\"ml323\"]=\"CHEMBL3182437\"\ncompounds2ids[\"sabutoclax\"]=\"CHEMBL1094250\"\n\n\nlen(compounds2ids)\n\n411"
  },
  {
    "objectID": "DeepMoA.html#chembl-moa-targets",
    "href": "DeepMoA.html#chembl-moa-targets",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "chEMBL MoA (targets)",
    "text": "chEMBL MoA (targets)\nGet the molecule targets of each drug (if available)\n\ncompounds2targets = dict() # required to store the drug targets \nfor drug in compounds2ids.keys():\n    compounds2targets[drug] = set()\n\nchembl_ids = list(compounds2ids.values()) # Chembl IDs of drugs\n\nfor drug in compounds2ids:\n    # we jump from compounds to targets through activities:\n    activities = new_client.mechanism.filter(parent_molecule_chembl_id__in=compounds2ids[drug]).only(\n        ['parent_molecule_chembl_id', 'target_chembl_id'])\n    # extracting target ChEMBL IDs from activities:\n    for act in activities:\n        compounds2targets[drug].add(act['target_chembl_id'])\n    print(drug)\n# We now know all targets for some drug\n\n\ncompounds2targets = {k: v for k, v in compounds2targets.items() if len(v) != 0 and len([x for x in list(v) if x is not None]) != 0 }\n\n\nlen(compounds2targets)\n\n267"
  },
  {
    "objectID": "DeepMoA.html#drug-slim-go-terms",
    "href": "DeepMoA.html#drug-slim-go-terms",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "Drug slim GO terms",
    "text": "Drug slim GO terms\nGet the GO terms of each target\n\ncompounds_GOterms = {}\nfor i in range(0, len(compounds2targets.keys())):\n    compound = list(compounds2targets.keys())[i]\n    GOterms_list = []\n    \n    for j in range(0, len(list(compounds2targets[compound]))):   \n        target = list(compounds2targets[compound])[j]\n        all_cross_references = list(new_client.target.filter(target_chembl_id=target).only(['target_components']).only(['target_components_xrefs']))[0]['target_components']\n        if len(all_cross_references)>0: # not all targets have annotated go_terms\n            for i in range(0, len(all_cross_references)):\n                GOterms = all_cross_references[i]\n                GOterms = pd.DataFrame(GOterms['target_component_xrefs'])\n                GOterms = pd.concat([GOterms,pd.Series([target]).repeat(len(GOterms)).reset_index().pop(0)],axis=1) # add target ID to dataframe \n                GOterms_list= GOterms_list + GOterms.values.tolist()\n    \n    compounds_GOterms[compound] =  pd.DataFrame(GOterms_list).drop_duplicates()\n    print(compound)\n\n\nlen(compounds_GOterms)\n\n270\n\n\nAdd GO terms found in CTRPv2\n\nCTRPv2_terms = pd.read_excel('ctrp_goterms_drugs.xlsx')  \n\n\n# add GO terms of drugs with or without annotations\nfor drug in CTRPv2_terms[\"Drug\"].unique():\n    if drug not in list(compounds_GOterms.keys()): # some drugs had no previous data, no annotations from chembl\n        compounds_GOterms[drug] = pd.DataFrame() # create empty dataframe\n\n    for term in list(CTRPv2_terms.loc[CTRPv2_terms[\"Drug\"]==drug][\"Field\"]):\n        compounds_GOterms[drug] = pd.concat([compounds_GOterms[drug],pd.DataFrame([term,\"\",\"GoProcess\",\"\"]).transpose()])\n    compounds_GOterms[drug] = compounds_GOterms[drug].drop_duplicates() \n\n\n# Delete drugs with no GOterms (some targets have no annotated GO terms)\ncompounds_GOterms = {k: v for k, v in compounds_GOterms.items() if len(v) != 0 } \n\n\nlen(compounds_GOterms)\n\n270"
  },
  {
    "objectID": "DeepMoA.html#match-go-terms",
    "href": "DeepMoA.html#match-go-terms",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "Match GO terms",
    "text": "Match GO terms\nFind all terms that match, terms that are part of both, the sparseGO graph and the drug slim results…\n\ndef load_ontology_extra_output(ontology_file, gene2id_mapping):\n    \"\"\"\n    Creates the directed graph of the GO terms and stores the connected elements in arrays.\n\n        Output\n        ------\n        dG: networkx.classes.digraph.DiGraph\n            Directed graph of all terms\n\n        terms_pairs: numpy.ndarray\n            Store the connection between a term and a term\n\n        genes_terms_pairs: numpy.ndarray\n            Store the connection between a gene and a term\n    \"\"\"\n\n    dG = nx.DiGraph() # Directed graph class\n\n    file_handle = open(ontology_file) #  Open the file that has genes and go terms\n\n    terms_pairs = [] # store the pairs between a term and a term\n    genes_terms_pairs = [] # store the pairs between a gene and a term\n\n    gene_set = set() # create a set (elements can't repeat)\n    term_direct_gene_map = {}\n    term_size_map = {}\n\n\n    for line in file_handle:\n\n        line = line.rstrip().split() # delete spaces and transform to list, line has 3 elements\n\n        # No me hace falta el if, no tengo que separar las parejas\n        if line[2] == 'default': # si el tercer elemento es default entonces se conectan los terms en el grafo\n            dG.add_edge(line[0], line[1]) # Add an edge between line[0] and line[1]\n            terms_pairs.append([line[0], line[1]]) # Add the pair to the list\n        else:\n            if line[1] not in gene2id_mapping: # se salta el gen si no es parte de los que estan en gene2id_mapping\n                print(line[1])\n                continue\n\n            genes_terms_pairs.append([line[0], line[1]]) # add the pair\n\n            if line[0] not in term_direct_gene_map: # si el termino todavia no esta en el diccionario lo agrega\n                term_direct_gene_map[ line[0] ] = set() # crea un set\n\n            term_direct_gene_map[line[0]].add(gene2id_mapping[line[1]]) # añadimos el gen al set de ese term\n\n            gene_set.add(line[1]) # añadimos el gen al set total de genes\n\n    terms_pairs = np.array(terms_pairs) # convert to 2d array\n    genes_terms_pairs = np.array(genes_terms_pairs) # convert to 2d array\n\n    file_handle.close()\n\n    print('There are', len(gene_set), 'genes')\n\n    for term in dG.nodes(): # hacemos esto para cada uno de los GO terms\n\n        term_gene_set = set() # se crea un set\n\n        if term in term_direct_gene_map:\n            term_gene_set = term_direct_gene_map[term] # genes conectados al term\n\n        deslist = nxadag.descendants(dG, term) #regresa todos sus GO terms descendientes (biological processes tiene 2085 descendientes, todos menos el mismo)\n\n        for child in deslist:\n            if child in term_direct_gene_map: # añadir los genes de sus descendientes\n                term_gene_set = term_gene_set | term_direct_gene_map[child] # union of both sets, ahora tiene todos los genes los suyos y los de sus descendientes\n\n        if len(term_gene_set) == 0:\n            print('There is empty terms, please delete term:', term)\n            sys.exit(1)\n        else:\n            # por ahora esta variable no me hace falta\n            term_size_map[term] = len(term_gene_set) # cantidad de genes en ese term  (tomando en cuenta sus descendientes)\n\n    leaves = [n for n in dG.nodes if dG.in_degree(n) == 0] # buscar la raiz\n    #leaves = [n for n,d in dG.in_degree() if d==0]\n\n    uG = dG.to_undirected() # Returns an undirected representation of the digraph\n    connected_subG_list = list(nxacc.connected_components(uG)) #list of all GO terms\n\n    # Verify my graph makes sense...\n    print('There are', len(leaves), 'roots:', leaves[0])\n    print('There are', len(dG.nodes()), 'terms')\n    print('There are', len(connected_subG_list), 'connected components')\n    if len(leaves) > 1:\n        print('There are more than 1 root of ontology. Please use only one root.')\n        sys.exit(1)\n    if len(connected_subG_list) > 1:\n        print( 'There are more than connected components. Please connect them.')\n        sys.exit(1)\n\n    return dG, terms_pairs, genes_terms_pairs, term_direct_gene_map, term_size_map\n\n\nSparseGO graph\n\n# Import SparseGO graph (to extract all nodes/terms)... \n\n# Load ontology: create the graph of connected GO terms\ndG, terms_pairs, genes_terms_pairs, term_direct_gene_map, term_size_map = load_ontology_extra_output(onto, gene2id_mapping)\n####\nsparseGO_terms = list(dG.nodes())\nsparseGO_terms.remove(\"GO:0008150\")\n\nThere are 14457 genes\nThere are 1 roots: GO:0008150\nThere are 4840 terms\nThere are 1 connected components\n\n\n\n\nFull GO graph\n\n# Import full graph (to find parents)...\nimport obonet\n#import networkx as nx\nurl = 'http://purl.obolibrary.org/obo/go/go-basic.obo'\nfull_graph = obonet.read_obo(url)\nfull_graph = full_graph.reverse() # change the direction of nodes\n[n for n in full_graph.nodes if full_graph.in_degree(n) == 0] # graph contains the 3 roots (BP,MF,CC)\n\n['GO:0003674', 'GO:0005575', 'GO:0008150']\n\n\n\n\nMatch terms!\nFind all terms that match, terms that are part of both, the sparseGO graph and the drug slim results… if the slim terms’ ascendants are a match, they are also added\n\n# Each model has DIFFERENT matches (the graph is different)\ncompounds_GOterms_matches = {}\nfor drug in compounds_GOterms.keys():\n    # choose drug\n    drug_df = compounds_GOterms[drug]\n    drug_slim_GOterms = set(drug_df.loc[drug_df[2] == \"GoProcess\"][0]) # only GO processes\n    #set(sparseGO_terms) & set(drug_slim_GOterms)\n    drug_matches = [] # store all directly matched terms and matches with all parents\n    for term in drug_slim_GOterms: # term ='GO:1902669' # buen ejemplo \n        \n        if term in sparseGO_terms: # is the term in the sparseGO terms? \n            drug_matches.append([1,term]) # add to list\n            #1: same term, 2:not direct match  (esto igual despues...the number indicates how direct is the relationship 0:same term, 1: parent, 2: grandpa, 3:...)\n        \n        # are its ascendants in the sparseGO terms? \n        parents = [source for source, _ in  full_graph.in_edges(term)] # parents of term\n        relationship = 2\n        while(len(parents)>0): # check all ascendants \n            #relationship+=1\n            parents = [source for source, _ in  full_graph.in_edges(parents)] # parents of parents\n        \n            for parent_term in parents: # add parents that match sparseGO terms \n                if parent_term in sparseGO_terms:\n                    drug_matches.append([relationship, parent_term])\n        \n        drug_matches = (pd.DataFrame(drug_matches).drop_duplicates()).values.tolist() # remove duplicates\n        compounds_GOterms_matches[drug] = drug_matches\n    print(drug)\n\n\n# delete drugs that have no matches\ncompounds_GOterms_matches = {i:j for i,j in compounds_GOterms_matches.items() if j != []}\n\n\nlen(compounds_GOterms_matches)\n\n265"
  },
  {
    "objectID": "DeepMoA.html#sparsego-terms-x-drugslim-terms-matrix",
    "href": "DeepMoA.html#sparsego-terms-x-drugslim-terms-matrix",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "SparseGO terms x drugSlim terms matrix",
    "text": "SparseGO terms x drugSlim terms matrix\n\nattribution_data_all.columns = attribution_data_all.columns.str.lower() # in order to match the term\n\n\nattribution_data_all.head()\n\n\n\n\n\n  \n    \n      \n      (-)-parthenolide\n      (5z)-7-oxozeaenol\n      5-fluorouracil\n      681640\n      a-443654\n      a-484954\n      a-770041\n      a-83-01\n      acadesine\n      acy-1215\n      ...\n      vemurafenib\n      ver-155008\n      vorapaxar\n      vorinostat:carboplatin (1:1 mol/mol)\n      vorinostat:navitoclax (4:1 mol/mol)\n      vu0155056\n      wz4002\n      wz8040\n      yl54\n      zebularine\n    \n    \n      GO_term\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      GO:0000012_1\n      0.009143\n      0.012238\n      0.014801\n      0.008749\n      0.028462\n      0.002892\n      0.021746\n      0.003400\n      0.002582\n      0.015812\n      ...\n      0.010666\n      0.008861\n      0.014170\n      0.006866\n      0.016116\n      0.010692\n      0.023399\n      0.022375\n      0.010787\n      0.007544\n    \n    \n      GO:0000012_2\n      -0.000285\n      -0.000928\n      -0.000579\n      0.000208\n      -0.001000\n      -0.000165\n      -0.002064\n      -0.000199\n      -0.000089\n      -0.000651\n      ...\n      -0.001053\n      -0.000468\n      -0.000831\n      -0.000112\n      -0.000545\n      -0.000622\n      -0.001353\n      -0.001063\n      -0.000853\n      -0.000307\n    \n    \n      GO:0000012_3\n      0.000593\n      0.001505\n      0.003211\n      0.000860\n      0.002106\n      -0.000137\n      0.003661\n      -0.000340\n      -0.000157\n      0.002306\n      ...\n      0.000033\n      0.001873\n      -0.000379\n      0.001317\n      -0.000275\n      0.000724\n      0.003970\n      0.005052\n      -0.000554\n      0.000269\n    \n    \n      GO:0000012_4\n      -0.000407\n      -0.000310\n      -0.000145\n      -0.000331\n      -0.000294\n      -0.000306\n      -0.000686\n      -0.000259\n      -0.000302\n      -0.000689\n      ...\n      -0.000542\n      -0.000382\n      0.000087\n      -0.000564\n      -0.002327\n      -0.000219\n      0.000312\n      0.000633\n      -0.000277\n      -0.000085\n    \n    \n      GO:0000012_5\n      -0.000152\n      -0.000454\n      -0.000350\n      0.000121\n      -0.000196\n      -0.000090\n      -0.000926\n      -0.000056\n      -0.000057\n      -0.000293\n      ...\n      -0.000339\n      -0.000374\n      -0.000076\n      -0.000136\n      -0.000653\n      -0.000179\n      -0.000458\n      -0.000314\n      -0.000226\n      -0.000019\n    \n  \n\n5 rows × 790 columns\n\n\n\n\nattribution_data_all.shape\n\n(29034, 790)\n\n\nOnly keep drugs that have annotated GO terms\n\nattribution_data_annotated = attribution_data_all[list(compounds_GOterms_matches.keys())]\n\n\nattribution_data_annotated.shape # 230 DRUGS\n\n(29034, 265)\n\n\n\nBuild drugSlim (MoA) matrix\n\nslim_matrix = attribution_data_annotated.copy() # copy dataframe in order to build a similar matrix \nfor col in slim_matrix.columns:\n    slim_matrix[col].values[:] = 0 # empty matrix \n\n\nfor drug in compounds_GOterms_matches.keys():\n    drug_matches = compounds_GOterms_matches[drug]\n    drug_matches_names = list(pd.DataFrame(drug_matches)[1])\n    \n    drug_matches_names_duplicated = []\n    for term in set(drug_matches_names):\n        for i in range(1,7):\n            drug_matches_names_duplicated.append(term+\"_\"+str(i))\n    \n    slim_matrix[drug][drug_matches_names_duplicated] = 1 # add a 1 if term is annotated to drug\n\n\nslim_matrix.head()\n\n\n\n\n\n  \n    \n      \n      5-fluorouracil\n      acadesine\n      acy-1215\n      afatinib\n      alectinib\n      alisertib\n      alvocidib\n      amuvatinib\n      apitolisib\n      arry-520\n      ...\n      sch-79797\n      rita\n      pifithrin-mu\n      l-685458\n      nutlin-3\n      pi-103\n      neopeltolide\n      avrainvillamide\n      indisulam\n      piperlongumine:mst-312 (1:1 mol/mol)\n    \n    \n      GO_term\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      GO:0000012_1\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      ...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      GO:0000012_2\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      ...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      GO:0000012_3\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      ...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      GO:0000012_4\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      ...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      GO:0000012_5\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      ...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n  \n\n5 rows × 265 columns"
  },
  {
    "objectID": "DeepMoA.html#create-models",
    "href": "DeepMoA.html#create-models",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "Create models",
    "text": "Create models\nSVM models…\n\n# Dictionaries to store results\nGO_terms_auc_svm = {}\nGO_terms_aupr_svm = {}\nGO_terms_precision_svm = {}\nGO_terms_auc_delta_logits = {}\n\n\n# Perform logistic\nfor goterm in sparseGO_terms:\n    # if (real_go_info[real_go_info[\"GO_term\"]==goterm+\"_1\"][\"layer_number\"]).values >3:\n    #     continue\n    \n    # store results of each cross validation\n    all_y_test = []\n    all_y_pred_proba = []\n    all_y_pred_proba_dis = []\n    all_y_pred = []\n    all_y_names = []\n\n    goterm_drugs = slim_matrix.loc[[goterm+\"_\"+str(1)]].values.flatten()\n\n    if sum(goterm_drugs) <= 16: # at least 2 annotated drugs in each group\n            continue\n\n    list_nodes = []\n    for i in range(1,7):\n        list_nodes.append(goterm+\"_\"+str(i))\n\n    score = attribution_data_annotated.loc[list_nodes].T\n    score_mod = score.divide(score.std()).fillna(0) # AFECTA MUCHO\n\n    # Separate drugs in 4 groups for cross-validation -----\n\n    # Split data in 2 groups (with train_test_split in order to have 0s in both groups)\n    X_part1,X_part2,y_part1,y_part2=train_test_split(score_mod,goterm_drugs,test_size=0.50,random_state=0,stratify=goterm_drugs)\n    # Split data again in 4 groups (split data previously split)\n    X_group1,X_group2,y_group1,y_group2=train_test_split(X_part1,y_part1,test_size=0.50,random_state=0,stratify=y_part1)\n    X_group3,X_group4,y_group3,y_group4=train_test_split(X_part2,y_part2,test_size=0.50,random_state=0,stratify=y_part2)\n\n    for i in  range(1,5):\n        vector = range(0,5)\n        group_number = str(i)\n        X_test = globals()[\"X_group\"+group_number]\n        y_test = globals()[\"y_group\"+group_number]\n\n        # Use the other 3 groups for training \n        keep = list({1,2,3,4}-{int(group_number)}) # remove group number of current test \n        X_train = pd.concat((globals()[\"X_group\"+str(keep[0])],globals()[\"X_group\"+str(keep[1])],globals()[\"X_group\"+str(keep[2])]))\n        y_train = np.concatenate((globals()[\"y_group\"+str(keep[0])],globals()[\"y_group\"+str(keep[1])],globals()[\"y_group\"+str(keep[2])]))\n        \n        #gamma = 1/(X_train.shape[1]*X_train.to_numpy().var())\n        gamma = \"scale\"\n        C=1\n        \n        svm_model = svm.SVC(C=C,gamma=gamma, kernel='rbf',\n                           class_weight=\"balanced\",\n                            tol=0.001,\n                            probability=True,\n                            random_state=1234)\n        # svm_model = svm.SVC(gamma='auto', kernel='rbf',class_weight=\"balanced\",probability=True)\n        \n        # fit the model with data\n        svm_model.fit(X_train,y_train)\n        y_pred=svm_model.predict(X_test)\n        y_pred_proba = svm_model.predict_proba(X_test)[::,1] # platt values\n        y_pred_proba_dis = svm_model.decision_function(X_test) # An SVM returns a real-valued prediction for each of the input data samples, which corresponds to its distance from the separating hyperplane.\n        #  decision_function SORTS the results from most probable class to the least probable one.\n        \n        all_y_test.append(y_test)\n        all_y_pred_proba.append(y_pred_proba)\n        all_y_pred_proba_dis.append(y_pred_proba_dis)\n        all_y_pred.append(y_pred)\n        all_y_names.append(X_test.index)\n\n    all_y_test = np.concatenate(all_y_test)\n    all_y_pred_proba = np.concatenate(all_y_pred_proba)\n    all_y_pred_proba_dis = np.concatenate(all_y_pred_proba_dis)\n    all_y_names = np.concatenate(all_y_names)\n    all_y_pred = np.concatenate(all_y_pred)\n    \n    percentage_go_annotations = sum(all_y_test)/len(all_y_test)\n    logits_apriori=np.log(percentage_go_annotations/(1-percentage_go_annotations))\n    logits_apost= np.log(all_y_pred_proba/(1-all_y_pred_proba))\n    delta_logits = logits_apost-logits_apriori\n\n    platt_matrix.loc[goterm,all_y_names] = all_y_pred_proba\n    distance_matrix.loc[goterm,all_y_names] = all_y_pred_proba_dis\n    slim_matrix_single_neuron.loc[goterm,all_y_names] = all_y_test\n    preds_svm_matrix.loc[goterm,all_y_names] = all_y_pred\n    \n    delta_logits_matrix.loc[goterm,all_y_names] = delta_logits\n\n    GO_terms_auc_delta_logits[goterm] = metrics.roc_auc_score(all_y_test, delta_logits)\n    GO_terms_auc_svm[goterm] = metrics.roc_auc_score(all_y_test, all_y_pred_proba)\n\n    precision, recall, thresholds = metrics.precision_recall_curve(all_y_test, all_y_pred_proba)\n    GO_terms_aupr_svm[goterm] = metrics.auc(recall, precision)\n    GO_terms_precision_svm[goterm] = metrics.precision_score(all_y_test, all_y_pred)\n\n\n# done with platt values\nGO_terms_auc_svm_df = pd.DataFrame(list(GO_terms_auc_svm.items()),columns = ['goterm','auc']).set_index(\"goterm\")\nGO_terms_auc_svm_df = GO_terms_auc_svm_df.dropna()\nGO_terms_auc_svm_df.sort_values(by=[\"auc\"], ascending=False).head()\n\n\n\n\n\n  \n    \n      \n      auc\n    \n    \n      goterm\n      \n    \n  \n  \n    \n      GO:1901029\n      0.959991\n    \n    \n      GO:0044342\n      0.956590\n    \n    \n      GO:0002326\n      0.955918\n    \n    \n      GO:0007006\n      0.955500\n    \n    \n      GO:1902236\n      0.954857\n    \n  \n\n\n\n\n\nprint(\"There are \" +str(len(GO_terms_auc_svm_df))+ \" svm models.\")\n\nThere are 1124 svm models.\n\n\n\n# only keep goterms that have a model \nplatt_matrix = platt_matrix.loc[list(GO_terms_auc_svm_df.index),:]\ndistance_matrix = distance_matrix.loc[list(GO_terms_auc_svm_df.index),:]\nslim_matrix_single_neuron  = slim_matrix_single_neuron.loc[list(GO_terms_auc_svm_df.index),:]\npreds_svm_matrix  = preds_svm_matrix.loc[list(GO_terms_auc_svm_df.index),:]\ndelta_logits_matrix  = delta_logits_matrix.loc[list(GO_terms_auc_svm_df.index),:]"
  },
  {
    "objectID": "DeepMoA.html#auc-histogram",
    "href": "DeepMoA.html#auc-histogram",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "AUC histogram",
    "text": "AUC histogram\n\nsns.set(rc={'figure.figsize':(10,6)})\nfig, ax = plt.subplots()\nperc = str(round((100*len(GO_terms_auc_svm_df[GO_terms_auc_svm_df[\"auc\"]>0.69])/len(GO_terms_auc_svm_df)),2))+\"%\"\nN, bins, patches = plt.hist(GO_terms_auc_svm_df, color=CB_color_cycle[6],bins=50, linewidth=0.1)\n\nfor i in range(0,len(bins)-1):\n    if bins[i]>0.69:\n        patches[i].set_facecolor(CB_color_cycle[2])\n\nplt.yticks(fontsize=16)\nplt.xticks(fontsize=16)\n\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\nax.spines['left'].set_visible(False)\nax.spines['bottom'].set_color('#DDDDDD')\n\n# Second, remove the ticks as well.\nax.tick_params(bottom=False, left=True)\n\n# Third, add a horizontal grid (but keep the vertical grid hidden).\n# Color the lines a light gray as well.\nax.set_axisbelow(True)\nax.yaxis.grid(True, color='#EEEEEE')\nax.xaxis.grid(False)\n\nplt.xlabel(\"AUC value\", fontsize=20)\nplt.ylabel(\"Number of GO term models\", fontsize=20)\ncolors2 = {'GO term models with AUC>=0.7':CB_color_cycle[2]}  \nlabels = list(colors2.keys())\nhandles = [plt.Rectangle((0,0),1,1, color=colors2[label]) for label in labels]\nplt.legend(handles, labels,fontsize=20, loc=\"lower left\", bbox_to_anchor=(0.35,-0.35))\nplt.text(0.71, 8, str(perc), fontsize=20,color='#333333')\nplt.title(\"Overall performance of the models using expression\", fontsize=24)\n# con el que mejor funciona es con la suma normal del attribution \nfig.tight_layout()\nfig.savefig(resultsdir+'modelsAUCsvm.png', transparent=True)"
  },
  {
    "objectID": "DeepMoA.html#auc-waterfall-plot",
    "href": "DeepMoA.html#auc-waterfall-plot",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "AUC waterfall plot",
    "text": "AUC waterfall plot\n\nGO_terms_auc_svm_df =GO_terms_auc_svm_df.sort_values(by=[\"auc\"], ascending=False)\n\n\nplt.rcParams['figure.figsize'] = (12, 9)\ndrugs = GO_terms_auc_svm_df.index\nrhos = GO_terms_auc_svm_df[\"auc\"]\n\npercentage = round((sum(rhos>0.69)/len(rhos))*100,1)\n\nfig, ax = plt.subplots()\n#colors = ['#208EA3' if (x < 0.5) else '#A4C61A' for x in rhos ]\ncolors = ['#C9C9C9' if (x < 0.69) else \"#6492CA\" for x in rhos ]\nax.bar(\n    x=drugs,\n    height=rhos,\n    edgecolor=colors,\n    linewidth=2\n)\nplt.xticks([])\nplt.yticks(fontsize=28)\n\n\n# First, let's remove the top, right and left spines (figure borders)\n# which really aren't necessary for a bar chart.\n# Also, make the bottom spine gray instead of black.\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\nax.spines['left'].set_visible(False)\nax.spines['bottom'].set_visible(False)\n#ax.spines['bottom'].set_color('#DDDDDD')\n\n# Second, remove the ticks as well.\nax.tick_params(bottom=False, left=False)\n\n# Third, add a horizontal grid (but keep the vertical grid hidden).\n# Color the lines a light gray as well.\nax.set_axisbelow(False)\nax.yaxis.grid(False)\n#ax.yaxis.grid(True, color='#EEEEEE')\nax.xaxis.grid(False)\n\n\n# Add labels and a title. Note the use of `labelpad` and `pad` to add some\n# extra space between the text and the tick labels.\nax.set_xlabel('SVM models', labelpad=-30, color='#333333',fontsize=50)\nax.set_ylabel('AUC-ROC value', labelpad=15, color='#333333',fontsize=50)\nax.set_title('', color='#333333',\n             weight='bold')\n\ncolors2 = {'High confidence drugs (r>0.5)':'#A4C61A'}  \nlabels = list(colors2.keys())\nhandles = [plt.Rectangle((0,0),1,1, color=colors2[label]) for label in labels]\n#plt.legend(handles, labels,fontsize=40, loc=\"lower left\",bbox_to_anchor=(0, -0.215))\nplt.text(77, 0.32, str(percentage)+\"%\", fontsize=60,color='#000000')\n\nplt.ylim((-0.1,1.1))\n# Make the chart fill out the figure better.\nfig.tight_layout()\nfig.savefig(resultsdir+'WaterfallModelsSVM.png', transparent=True)"
  },
  {
    "objectID": "DeepMoA.html#auc-boxplot-by-parents",
    "href": "DeepMoA.html#auc-boxplot-by-parents",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "AUC boxplot by parents",
    "text": "AUC boxplot by parents\n\n# Add number of parents\nnumber_parents = {}\nlevels = {}\nfor i in range(0,len(GO_terms_auc_svm_df.index)):\n    term = GO_terms_auc_svm_df.index[i]\n    number_parents[GO_terms_auc_svm_df.index[i]]=len([source for source, _ in  dG.in_edges(term)])\n    levels[GO_terms_auc_svm_df.index[i]]=level_number[term]-1\nlevels = pd.DataFrame.from_dict(levels, orient='index')\nnumber_parents = pd.DataFrame.from_dict(number_parents, orient='index')\n\nGO_terms_auc_svm_df = pd.concat([GO_terms_auc_svm_df, levels,number_parents], axis=1)\nGO_terms_auc_svm_df.columns = [\"auc\",\"levels\",\"parents\"]\n\n\nGO_terms_auc_svm_df = GO_terms_auc_svm_df.sort_values(by=[\"levels\"], ascending=True)\n\n\nGO_terms_auc_svm_df.head()\n\n\n\n\n\n  \n    \n      \n      auc\n      levels\n      parents\n    \n  \n  \n    \n      GO:2000352\n      0.735461\n      0\n      3\n    \n    \n      GO:0010592\n      0.672245\n      0\n      8\n    \n    \n      GO:0035787\n      0.785342\n      0\n      2\n    \n    \n      GO:2000811\n      0.807018\n      0\n      3\n    \n    \n      GO:0090314\n      0.790000\n      0\n      7\n    \n  \n\n\n\n\n\nc = ['#E8384F', '#FD817D', '#FDAE33','#EECC16', '#A4C61A', '#37A862',\"#208EA3\",\"#3B6EAB\"]\n\ndf = px.data.tips()\nfig = px.box(GO_terms_auc_svm_df, x=\"levels\", y=\"auc\",\n             color=\"levels\",\n            color_discrete_sequence=c,\n             width =600,\n             height=400,\n              template=\"simple_white\",\n              labels=dict(levels=\"Level of GO hierarchy\", auc=\"AUROC\")\n            )\nfig.update_traces(width=0.9)\n\nfig.add_shape( # add a horizontal \"target\" line\n    type=\"line\", line_color=\"salmon\", line_width=3, opacity=1, line_dash=\"dot\",\n    x0=0, x1=1, xref=\"paper\", y0=0.7, y1=0.7, yref=\"y\"\n)\n\n\nfig.update_layout(\n   title=dict(text=\"<b> AUC value grouped by level of GO hierarchy <b>\",\n             x=0.5,\n             y=0.9,\n              font=dict(size=20),\n              xanchor='center',\n              yanchor='top'),\n    xaxis=dict(ticks=\"\", showticklabels=False, showgrid=False, zeroline=False),\n    yaxis=dict(ticks=\"\", showticklabels=True, showgrid=True, zeroline=False),\n #   yaxis_range=[min(yy.flatten()),max(yy.flatten())],\n  #  xaxis_range=[min(xx.flatten()),max(xx.flatten())],\n    legend=dict(x=1.1, y=1, orientation=\"v\",font=dict(size=16)),\n    paper_bgcolor='rgba(0,0,0,0)',\n    plot_bgcolor='rgba(0,0,0,0)',\n    font=dict(family='Roboto',color= \"#36382E\",size=20)\n    )\n\nfig.show()\n# pio.write_image(fig, resultsdir+\"AUC_levels.png\", width=600, height=400,scale=8)"
  },
  {
    "objectID": "DeepMoA.html#top-15-predicted-go-terms",
    "href": "DeepMoA.html#top-15-predicted-go-terms",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "TOP 15 PREDICTED GO TERMS",
    "text": "TOP 15 PREDICTED GO TERMS\n\ntop15goterms= np.array(GO_terms_auc_svm_df.sort_values(by=[\"auc\"], ascending=False)[0:15].index)\n\nGet Top GO term names\n\ntop15goterms_1 = []\nfor goterm in top15goterms:\n    top15goterms_1.append(goterm+\"_\"+str(1))\nreal_go_info_mod_best = real_go_info[real_go_info.GO_term.isin(top15goterms_1)]\nreal_go_info_mod_best.GO_term = real_go_info_mod_best.GO_term.str.replace(\"_1\",\"\")\n\n\ntop15goterms_auc = GO_terms_auc_svm_df.sort_values(by=[\"auc\"], ascending=False)[0:15].reset_index()\ntop15goterms_auc.columns=[\"GO_term\",\"auc\",\"levels\",\"parents\"]\n\n\ntop15goterms_auc = top15goterms_auc.merge(real_go_info_mod_best[real_go_info_mod_best[\"GO_term\"].isin(top15goterms)], on=\"GO_term\")\n\n\ntop15goterms_auc\n\n\n\n\n\n  \n    \n      \n      GO_term\n      auc\n      levels\n      parents\n      Name\n      layer_number\n    \n  \n  \n    \n      0\n      GO:1901029\n      0.959991\n      0\n      10\n      Negative regulation of mitochondrial outer membrane permeabilization involved in apoptotic signaling pathway (1)\n      0.0\n    \n    \n      1\n      GO:0044342\n      0.956590\n      1\n      1\n      Type b pancreatic cell proliferation (1)\n      1.0\n    \n    \n      2\n      GO:0002326\n      0.955918\n      0\n      2\n      B cell lineage commitment (1)\n      0.0\n    \n    \n      3\n      GO:0007006\n      0.955500\n      3\n      2\n      Mitochondrial membrane organization (1)\n      3.0\n    \n    \n      4\n      GO:1902236\n      0.954857\n      0\n      6\n      Negative regulation of endoplasmic reticulum stress-induced intrinsic apoptotic signaling pathway (1)\n      0.0\n    \n    \n      5\n      GO:1900118\n      0.953573\n      0\n      3\n      Negative regulation of execution phase of apoptosis (1)\n      0.0\n    \n    \n      6\n      GO:0030279\n      0.950408\n      1\n      3\n      Negative regulation of ossification (1)\n      1.0\n    \n    \n      7\n      GO:0051452\n      0.949592\n      1\n      1\n      Intracellular ph reduction (1)\n      1.0\n    \n    \n      8\n      GO:0033033\n      0.944694\n      0\n      3\n      Negative regulation of myeloid cell apoptotic process (1)\n      0.0\n    \n    \n      9\n      GO:0060020\n      0.944502\n      0\n      1\n      Bergmann glial cell differentiation (1)\n      0.0\n    \n    \n      10\n      GO:0048743\n      0.941837\n      0\n      11\n      Positive regulation of skeletal muscle fiber development (1)\n      0.0\n    \n    \n      11\n      GO:0097345\n      0.940950\n      1\n      5\n      Mitochondrial outer membrane permeabilization (1)\n      1.0\n    \n    \n      12\n      GO:0006959\n      0.940779\n      3\n      1\n      Humoral immune response (1)\n      3.0\n    \n    \n      13\n      GO:1901863\n      0.940703\n      1\n      3\n      Positive regulation of muscle tissue development (1)\n      1.0\n    \n    \n      14\n      GO:0030890\n      0.939581\n      0\n      9\n      Positive regulation of b cell proliferation (1)\n      0.0\n    \n  \n\n\n\n\n\nplt.rcParams['figure.figsize'] = (16, 22)\nfig, ax = plt.subplots()\nrhos_top=top15goterms_auc[\"auc\"][0:10]\ndrugs_top=top15goterms_auc[\"GO_term\"][0:10]\n\ncolors = [CB_color_cycle[2] if (x < 0.5) else \"#6492CA\" for x in rhos_top ]\nbars = ax.bar(\n    x=drugs_top,\n    height=rhos_top,\n    edgecolor=\"none\",\n    linewidth=1,\n    color = colors,\n    width=0.9\n)\n#plt.yticks(fontsize=30)\nplt.yticks([])\nplt.xticks([])\n\n# First, let's remove the top, right and left spines (figure borders)\n# which really aren't necessary for a bar chart.\n# Also, make the bottom spine gray instead of black.\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\nax.spines['left'].set_visible(False)\nax.spines['bottom'].set_color('#DDDDDD')\n\n\n\n# Third, add a horizontal grid (but keep the vertical grid hidden).\n# Color the lines a light gray as well.\nax.set_axisbelow(True)\n#ax.yaxis.grid(False, color='#EEEEEE')\nax.xaxis.grid(False)\n\n#plt.xticks(rotation=80,fontsize=40)\n\n# Add text annotations to the top of the bars.\nbar_color = bars[0].get_facecolor()\nfor bar in bars:\n  ax.text(\n      \n      bar.get_x() + bar.get_width() / 2,\n      bar.get_height() + 0.03,\n      round(bar.get_height(), 3),\n      horizontalalignment='center',\n      #color=bar_color,\n      color='#000000',\n      weight='bold',\n      fontsize=80,\n      rotation=\"vertical\"\n  )\n\ni=0\nfor bar in bars:\n    ax.text(\n      \n      bar.get_x() + bar.get_width() / 2,\n      0.45,\n      drugs_top[i],\n      horizontalalignment='center',\n      #color=bar_color,\n      color='#000000',\n      #weight='bold',\n      fontsize=90,\n      rotation=\"vertical\"\n    )\n    i=i+1\n\nax.tick_params(bottom=True, left=False, axis='x', which='major', pad=-1)\n# Add labels and a title. Note the use of `labelpad` and `pad` to add some\n# extra space between the text and the tick labels.\nax.set_xlabel('', labelpad=15, color='#333333')\n#ax.set_ylabel('r', labelpad=15, color='#333333',fontsize=30)\nax.set_title('', color='#333333',\n             weight='bold')\n\n# Make the chart fill out the figure better.\nfig.tight_layout()\n\nfig.savefig(resultsdir+'top10svm_models.png', transparent=True)"
  },
  {
    "objectID": "DeepMoA.html#worst-15-predicted-go-terms",
    "href": "DeepMoA.html#worst-15-predicted-go-terms",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "WORST 15 PREDICTED GO TERMS",
    "text": "WORST 15 PREDICTED GO TERMS\n\nworst15goterms= np.array(GO_terms_auc_svm_df.sort_values(by=[\"auc\"], ascending=True)[0:15].index)\n\nGet Worst GO term names\n\nworst15goterms_1 = []\nfor goterm in worst15goterms:\n    worst15goterms_1.append(goterm+\"_\"+str(1))\nreal_go_info_mod_worst = real_go_info[real_go_info.GO_term.isin(worst15goterms_1)]\nreal_go_info_mod_worst.GO_term = real_go_info_mod_worst.GO_term.str.replace(\"_1\",\"\")\n\n\nworst15goterms_auc = GO_terms_auc_svm_df.sort_values(by=[\"auc\"], ascending=True)[0:15].reset_index()\nworst15goterms_auc.columns=[\"GO_term\",\"auc\",\"levels\",\"parents\"]\n\n\nworst15goterms_auc.merge(real_go_info_mod_worst[real_go_info_mod_worst[\"GO_term\"].isin(worst15goterms)], on=\"GO_term\")\n\n\n\n\n\n  \n    \n      \n      GO_term\n      auc\n      levels\n      parents\n      Name\n      layer_number\n    \n  \n  \n    \n      0\n      GO:0032412\n      0.351992\n      3\n      3\n      Regulation of ion transmembrane transporter activity (1)\n      3.0\n    \n    \n      1\n      GO:0017157\n      0.363878\n      3\n      5\n      Regulation of exocytosis (1)\n      3.0\n    \n    \n      2\n      GO:0014013\n      0.372925\n      1\n      2\n      Regulation of gliogenesis (1)\n      1.0\n    \n    \n      3\n      GO:0071356\n      0.384013\n      3\n      2\n      Cellular response to tumor necrosis factor (1)\n      3.0\n    \n    \n      4\n      GO:0006163\n      0.385537\n      4\n      2\n      Purine nucleotide metabolic process (1)\n      4.0\n    \n    \n      5\n      GO:0048660\n      0.389564\n      2\n      2\n      Regulation of smooth muscle cell proliferation (1)\n      2.0\n    \n    \n      6\n      GO:2000146\n      0.390756\n      5\n      3\n      Negative regulation of cell motility (1)\n      5.0\n    \n    \n      7\n      GO:0019827\n      0.393045\n      2\n      1\n      Stem cell population maintenance (1)\n      2.0\n    \n    \n      8\n      GO:0006475\n      0.395102\n      3\n      1\n      Internal protein amino acid acetylation (1)\n      3.0\n    \n    \n      9\n      GO:0015833\n      0.395593\n      5\n      2\n      Peptide transport (1)\n      5.0\n    \n    \n      10\n      GO:0097305\n      0.397744\n      2\n      1\n      Response to alcohol (1)\n      2.0\n    \n    \n      11\n      GO:0060291\n      0.402420\n      2\n      2\n      Long-term synaptic potentiation (1)\n      2.0\n    \n    \n      12\n      GO:0032967\n      0.406570\n      0\n      3\n      Positive regulation of collagen biosynthetic process (1)\n      0.0\n    \n    \n      13\n      GO:0009743\n      0.407096\n      4\n      1\n      Response to carbohydrate (1)\n      4.0\n    \n    \n      14\n      GO:0001659\n      0.410349\n      1\n      2\n      Temperature homeostasis (1)\n      1.0"
  },
  {
    "objectID": "DeepMoA.html#aupr-histogram",
    "href": "DeepMoA.html#aupr-histogram",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "AUPR histogram",
    "text": "AUPR histogram\n\nGO_terms_aupr_svm_df = pd.DataFrame(list(GO_terms_aupr_svm.items()),columns = ['goterm','aupr']).set_index(\"goterm\")\nGO_terms_aupr_svm_df = GO_terms_aupr_svm_df.dropna()\nGO_terms_aupr_svm_df.sort_values(by=[\"aupr\"], ascending=False).head()\n\n\n\n\n\n  \n    \n      \n      aupr\n    \n    \n      goterm\n      \n    \n  \n  \n    \n      GO:0006468\n      0.913629\n    \n    \n      GO:0001782\n      0.908636\n    \n    \n      GO:0036211\n      0.886811\n    \n    \n      GO:0009058\n      0.886773\n    \n    \n      GO:0033033\n      0.881536\n    \n  \n\n\n\n\n\n# Add number of parents\nnumber_parents = {}\nlevels = {}\nfor i in range(0,len(GO_terms_aupr_svm_df.index)):\n    term = GO_terms_aupr_svm_df.index[i]\n    number_parents[GO_terms_aupr_svm_df.index[i]]=len([source for source, _ in  dG.in_edges(term)])\n    levels[GO_terms_aupr_svm_df.index[i]]=level_number[term]-1\nlevels = pd.DataFrame.from_dict(levels, orient='index')\nnumber_parents = pd.DataFrame.from_dict(number_parents, orient='index')\n\nGO_terms_aupr_svm_df = pd.concat([GO_terms_aupr_svm_df, levels,number_parents], axis=1)\nGO_terms_aupr_svm_df.columns = [\"aupr\",\"levels\",\"parents\"]\n\n\nGO_terms_aupr_svm_df = GO_terms_aupr_svm_df.sort_values(by=[\"levels\"], ascending=True)\n\n\n\nc = ['#E8384F', '#FD817D', '#FDAE33','#EECC16', '#A4C61A', '#37A862',\"#208EA3\",\"#3B6EAB\"]\n\ndf = px.data.tips()\nfig = px.box(GO_terms_aupr_svm_df, x=\"levels\", y=\"aupr\",\n             color=\"levels\",\n            color_discrete_sequence=c,\n             width =600,\n             height=400,\n              template=\"simple_white\",\n              labels=dict(levels=\"Level of GO hierarchy\", aupr=\"AUPR\")\n            )\nfig.update_traces(width=0.9)\n\nfig.add_shape( # add a horizontal \"target\" line\n    type=\"line\", line_color=\"salmon\", line_width=3, opacity=1, line_dash=\"dot\",\n    x0=0, x1=1, xref=\"paper\", y0=0.7, y1=0.7, yref=\"y\"\n)\n\n\nfig.update_layout(\n   title=dict(text=\"<b> AUPR value grouped by level of GO hierarchy <b>\",\n             x=0.5,\n             y=0.9,\n              font=dict(size=20),\n              xanchor='center',\n              yanchor='top'),\n    xaxis=dict(ticks=\"\", showticklabels=False, showgrid=False, zeroline=False),\n    yaxis=dict(ticks=\"\", showticklabels=True, showgrid=True, zeroline=False),\n #   yaxis_range=[min(yy.flatten()),max(yy.flatten())],\n  #  xaxis_range=[min(xx.flatten()),max(xx.flatten())],\n    legend=dict(x=1.1, y=1, orientation=\"v\",font=dict(size=16)),\n    paper_bgcolor='rgba(0,0,0,0)',\n    plot_bgcolor='rgba(0,0,0,0)',\n    font=dict(family='Roboto',color= \"#36382E\",size=20)\n    )\n\nfig.show()\n# pio.write_image(fig, resultsdir+\"AUPR_levels.png\", width=600, height=400,scale=8)\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json"
  },
  {
    "objectID": "DeepMoA.html#example-prediction",
    "href": "DeepMoA.html#example-prediction",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "Example prediction",
    "text": "Example prediction\n\ndef f2(goterm):    \n    return goterm\n\n\ncombobox_go = interactive(f2, goterm=widgets.Combobox(options=list(GO_terms_auc_svm_df.sort_values(by=[\"auc\"], ascending=False).index)))\n\nChoose drug to study…\n\ndisplay(combobox_go)\n\n\n\n\n\nselected_go = combobox_go.result\n\n\n#auc\nplt.rcParams['figure.figsize'] = (4, 2)\nfpr, tpr, _ = metrics.roc_curve(slim_matrix_single_neuron.loc[selected_go],  platt_matrix.loc[selected_go])\nauc = metrics.roc_auc_score(slim_matrix_single_neuron.loc[selected_go],  platt_matrix.loc[selected_go])\nplt.plot(fpr,tpr,label=\"data 1, auc=\"+str(auc))\nplt.legend(loc=4)\nplt.show()\n\nplot = pd.concat([pd.DataFrame(slim_matrix_single_neuron.loc[selected_go]),pd.DataFrame(platt_matrix.loc[selected_go])], axis=1)\nplot.columns = [\"slim\",\"probability\"]\nax = sns.boxplot(x=\"slim\", y=\"probability\", data=plot,showfliers=False )\n\n\n\n\n\n\n\n\n#auc \nfpr, tpr, _ = metrics.roc_curve(slim_matrix_single_neuron.loc[selected_go],  delta_logits_matrix.loc[selected_go])\nauc = metrics.roc_auc_score(slim_matrix_single_neuron.loc[selected_go],  delta_logits_matrix.loc[selected_go])\nplt.plot(fpr,tpr,label=\"data 1, auc=\"+str(auc))\nplt.legend(loc=4)\nplt.show()\n\nplot = pd.concat([pd.DataFrame(slim_matrix_single_neuron.loc[selected_go]),pd.DataFrame(delta_logits_matrix.loc[selected_go])], axis=1)\nplot.columns = [\"slim\",\"probability\"]\nax = sns.boxplot(x=\"slim\", y=\"probability\", data=plot,showfliers=False )\n\n\n\n\n\n\n\n\nplt.rcParams['figure.figsize'] = (2, 2)\nmetrics.ConfusionMatrixDisplay.from_predictions(slim_matrix_single_neuron.loc[selected_go], preds_svm_matrix.loc[selected_go])\nplt.grid(visible=None)\n\nprint(\"Accuracy:\",metrics.accuracy_score(slim_matrix_single_neuron.loc[selected_go], preds_svm_matrix.loc[selected_go]))\nprint(\"Precision:\",metrics.precision_score(slim_matrix_single_neuron.loc[selected_go], preds_svm_matrix.loc[selected_go]))\nprint(\"Recall:\",metrics.recall_score(slim_matrix_single_neuron.loc[selected_go], preds_svm_matrix.loc[selected_go])) #TP / (TP+FN)\nprint(\"AUC with score:\",auc) #TP / (TP+FN)\n\nAccuracy: 0.9735849056603774\nPrecision: 0.7894736842105263\nRecall: 0.8333333333333334\nAUC with score: 0.9565901934322987\n\n\n\n\n\nTN - FP\nFN - TP\n\nplt.rcParams['figure.figsize'] = (4, 2)\nprecision, recall, thresholds = metrics.precision_recall_curve(slim_matrix_single_neuron.loc[selected_go],  preds_svm_matrix.loc[selected_go])\nauc_precision_recall = metrics.auc(recall, precision)\nplt.plot(recall, precision,label=str(auc_precision_recall))\nplt.legend(loc=4)\nplt.show()"
  },
  {
    "objectID": "DeepMoA.html#metrics-drugs",
    "href": "DeepMoA.html#metrics-drugs",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "METRICS drugs",
    "text": "METRICS drugs\n\nauc_drugs = {}\naupr_drugs = {}\nprecision_drugs = {}\nfor drug in list(slim_matrix_single_neuron.columns):\n    if slim_matrix_single_neuron.loc[:,drug].sum() ==0:\n        continue\n    #fpr, tpr, _ = metrics.roc_curve(slim_matrix_single_neuron.loc[:,drug], logits_matrix.loc[:,drug])\n    #auc_drugs[drug]  = metrics.auc(fpr, tpr)\n    auc_drugs[drug] = metrics.roc_auc_score(slim_matrix_single_neuron.loc[:,drug],  platt_matrix.loc[:,drug])\n    precision, recall, thresholds = metrics.precision_recall_curve(slim_matrix_single_neuron.loc[:,drug],  platt_matrix.loc[:,drug])\n    aupr_drugs[drug] = metrics.auc(recall, precision)\n    precision_drugs[drug] = metrics.precision_score(slim_matrix_single_neuron.loc[:,drug],  preds_svm_matrix.loc[:,drug])\n\nauc_drugs_df = pd.DataFrame(list(auc_drugs.items()),columns = ['goterm','auc']).set_index(\"goterm\")\nauc_drugs_df = auc_drugs_df.dropna()\n\naupr_drugs_df = pd.DataFrame(list(aupr_drugs.items()),columns = ['goterm','aupr']).set_index(\"goterm\")\naupr_drugs_df = aupr_drugs_df.dropna()\n\nprecision_drugs_df = pd.DataFrame(list(precision_drugs.items()),columns = ['goterm','precision']).set_index(\"goterm\")\nprecision_drugs_df = precision_drugs_df.dropna()\n\n\nAUC histogram drugs\n\nsns.set(rc={'figure.figsize':(10,6)})\nfig, ax = plt.subplots()\nperc = str(round((100*len(auc_drugs_df[auc_drugs_df[\"auc\"]>0.7])/len(auc_drugs_df)),2))+\"%\"\nN, bins, patches = plt.hist(auc_drugs_df, color=CB_color_cycle[6],bins=50, linewidth=0.1)\n\nfor i in range(0,len(bins)-1):\n    if bins[i]>0.7:\n        patches[i].set_facecolor(CB_color_cycle[5])\n\nplt.yticks(fontsize=16)\nplt.xticks(fontsize=16)\n\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\nax.spines['left'].set_visible(False)\nax.spines['bottom'].set_color('#DDDDDD')\n\n# Second, remove the ticks as well.\nax.tick_params(bottom=False, left=True)\n\n# Third, add a horizontal grid (but keep the vertical grid hidden).\n# Color the lines a light gray as well.\nax.set_axisbelow(True)\nax.yaxis.grid(True, color='#EEEEEE')\nax.xaxis.grid(False)\n\nplt.xlabel(\"AUC value\", fontsize=20)\nplt.ylabel(\"Number of drugs\", fontsize=20)\ncolors2 = {'Drugs with AUC>=0.7':CB_color_cycle[5]}  \nlabels = list(colors2.keys())\nhandles = [plt.Rectangle((0,0),1,1, color=colors2[label]) for label in labels]\nplt.legend(handles, labels,fontsize=20, loc=\"lower left\", bbox_to_anchor=(0.35,-0.35))\nplt.text(0.79, 6, str(perc), fontsize=20,color='#333333')\nplt.title(\"Overall performance by drugs using mutations\", fontsize=24)\n# con el que mejor funciona es con la suma normal del attribution \nfig.tight_layout()\nfig.savefig(resultsdir+'drugsAUC.png', transparent=True)\n\n\n\n\n\n\nAUC waterfall plot drugs\n\nauc_drugs_df =auc_drugs_df.sort_values(by=[\"auc\"], ascending=False)\n\n\nplt.rcParams['figure.figsize'] = (12, 9)\ndrugs = auc_drugs_df.index\nrhos = auc_drugs_df[\"auc\"]\n\npercentage = round((sum(rhos>0.69)/len(rhos))*100,1)\n\nfig, ax = plt.subplots()\n#colors = ['#208EA3' if (x < 0.5) else '#A4C61A' for x in rhos ]\ncolors = ['#C9C9C9' if (x < 0.69) else \"#B678BE\" for x in rhos ]\nax.bar(\n    x=drugs,\n    height=rhos,\n    edgecolor=colors,\n    linewidth=3\n)\nplt.xticks([])\nplt.yticks(fontsize=28)\n\n\n# First, let's remove the top, right and left spines (figure borders)\n# which really aren't necessary for a bar chart.\n# Also, make the bottom spine gray instead of black.\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\nax.spines['left'].set_visible(False)\nax.spines['bottom'].set_visible(False)\n#ax.spines['bottom'].set_color('#DDDDDD')\n\n# Second, remove the ticks as well.\nax.tick_params(bottom=False, left=False)\n\n# Third, add a horizontal grid (but keep the vertical grid hidden).\n# Color the lines a light gray as well.\nax.set_axisbelow(False)\nax.yaxis.grid(False)\n#ax.yaxis.grid(True, color='#EEEEEE')\nax.xaxis.grid(False)\n\n\n# Add labels and a title. Note the use of `labelpad` and `pad` to add some\n# extra space between the text and the tick labels.\nax.set_xlabel('Drugs', labelpad=-30, color='#333333',fontsize=50)\nax.set_ylabel('AUC-ROC value', labelpad=15, color='#333333',fontsize=50)\nax.set_title('', color='#333333',\n             weight='bold')\n\ncolors2 = {'High confidence drugs (r>0.5)':'#A4C61A'}  \nlabels = list(colors2.keys())\nhandles = [plt.Rectangle((0,0),1,1, color=colors2[label]) for label in labels]\n#plt.legend(handles, labels,fontsize=40, loc=\"lower left\",bbox_to_anchor=(0, -0.215))\nplt.text(77, 0.32, str(percentage)+\"%\", fontsize=60,color='#000000')\n\nplt.ylim((-0.1,1.1))\n# Make the chart fill out the figure better.\nfig.tight_layout()\nfig.savefig(resultsdir+'WaterfallModelsSVM_drugs.png', transparent=True)\n\n\n\n\n\n\nAUPR histogram drugs\n\nsns.set(rc={'figure.figsize':(5,3)})\nperc = str(round((100*len(aupr_drugs_df[aupr_drugs_df[\"aupr\"]>0.69])/len(aupr_drugs_df)),2))+\"%\"\nN, bins, patches = plt.hist(aupr_drugs_df, color=CB_color_cycle[6],bins=50, linewidth=0.1)\nfor i in range(0,len(bins)-1):\n    if bins[i]>0.69:\n        patches[i].set_facecolor(CB_color_cycle[3])\n\nplt.xlabel(\"AUPR drugs\", fontsize=16)  \nplt.title(perc, fontsize=16)\n\nText(0.5, 1.0, '33.58%')\n\n\n\n\n\n\n\nExample drug prediction\n\ndef f(drug):    \n    \n    return drug\n\n\npredictions_nodes = []\nfor goterm in list(platt_matrix.index):\n    predictions_nodes.append(goterm+\"_\"+str(1))\n\n\n# add names to go terms\nreal_go_info_svm= real_go_info[real_go_info.GO_term.isin(predictions_nodes)]\nreal_go_info_svm.GO_term = real_go_info_svm.GO_term.str.replace(\"_1\",\"\")\n\n\ncombobox = interactive(f, drug=widgets.Combobox(options=list(precision_drugs_df.sort_values(by=[\"precision\"], ascending=False).index)))\n\nChoose drug to study…\n\ndisplay(combobox)\n\n\n\n\n\nselected_drug_name = combobox.result\n\n\nsns.set(rc={'figure.figsize':(4,2)})\n#auc\nfpr, tpr, _ = metrics.roc_curve(slim_matrix_single_neuron.loc[:,selected_drug_name], platt_matrix.loc[:,selected_drug_name] )\nauc = metrics.roc_auc_score(slim_matrix_single_neuron.loc[:,selected_drug_name],  platt_matrix.loc[:,selected_drug_name])\nplt.plot(fpr,tpr,label=\"data 1, auc=\"+str(auc))\nplt.legend(loc=4)\nplt.show()\n\nplot = pd.concat([pd.DataFrame(slim_matrix_single_neuron.loc[:,selected_drug_name]),pd.DataFrame(platt_matrix.loc[:,selected_drug_name])], axis=1)\nplot.columns = [\"slim\",\"svm score\"]\nax = sns.boxplot(x=\"slim\", y=\"svm score\", data=plot,showfliers=False )\n\n\n\n\n\n\n\n\nplot = pd.concat([pd.DataFrame(slim_matrix.loc[:,selected_drug_name]),pd.DataFrame(attribution_data_annotated.loc[:,selected_drug_name]*1e4)], axis=1)\nplot.columns = [\"slim\",\"attribution\"]\nax = sns.boxplot(x=\"slim\", y=\"attribution\", data=plot,showfliers=True )\n\n\n\n\n\nmetrics.ConfusionMatrixDisplay.from_predictions(slim_matrix_single_neuron.loc[:,selected_drug_name].round(), preds_svm_matrix.loc[:,selected_drug_name])\n\n<sklearn.metrics._plot.confusion_matrix.ConfusionMatrixDisplay at 0x2ce2b82e0>\n\n\n\n\n\n\nprint(\"Accuracy:\",metrics.accuracy_score(slim_matrix_single_neuron.loc[:,selected_drug_name], preds_svm_matrix.loc[:,selected_drug_name]))\nprint(\"Precision:\",metrics.precision_score(slim_matrix_single_neuron.loc[:,selected_drug_name], preds_svm_matrix.loc[:,selected_drug_name]))\nprint(\"Recall:\",metrics.recall_score(slim_matrix_single_neuron.loc[:,selected_drug_name], preds_svm_matrix.loc[:,selected_drug_name])) #TP / (TP+FN)\nprint(\"AUC with score:\",auc) \n\nAccuracy: 0.7197508896797153\nPrecision: 0.9100917431192661\nRecall: 0.6509186351706037\nAUC with score: 0.8904018213192963\n\n\n\n# LOS LOGITS DE TEST!!\ntrain_drug_logs = pd.DataFrame(delta_logits_matrix.loc[:,selected_drug_name]).reset_index()\ntrain_drug_logs.columns  = [\"GO_term\",\"probability\"]\ntrain_drug_logs = train_drug_logs.merge(real_go_info_svm, on=\"GO_term\")\ntrain_drug_logs.sort_values(by=[\"probability\"], ascending=False).head(10)\n\n\n\n\n\n  \n    \n      \n      GO_term\n      probability\n      Name\n      layer_number\n    \n  \n  \n    \n      329\n      GO:0006939\n      2.871769\n      Smooth muscle contraction (1)\n      3.0\n    \n    \n      381\n      GO:0048041\n      2.568268\n      Focal adhesion assembly (1)\n      2.0\n    \n    \n      144\n      GO:0002318\n      2.533049\n      Myeloid progenitor cell differentiation (1)\n      0.0\n    \n    \n      408\n      GO:0048008\n      2.529048\n      Platelet-derived growth factor receptor signaling pathway (1)\n      1.0\n    \n    \n      595\n      GO:0032526\n      2.437785\n      Response to retinoic acid (1)\n      1.0\n    \n    \n      822\n      GO:0046651\n      2.300822\n      Lymphocyte proliferation (1)\n      4.0\n    \n    \n      183\n      GO:0048608\n      2.222701\n      Reproductive structure development (1)\n      3.0\n    \n    \n      458\n      GO:0048839\n      2.066365\n      Inner ear development (1)\n      3.0\n    \n    \n      793\n      GO:1901888\n      2.058388\n      Regulation of cell junction assembly (1)\n      2.0\n    \n    \n      956\n      GO:0002327\n      1.921062\n      Immature b cell differentiation (1)\n      0.0"
  },
  {
    "objectID": "DeepMoA.html#final-model-svm",
    "href": "DeepMoA.html#final-model-svm",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "Final model SVM",
    "text": "Final model SVM\nOnce the models have been cross-validated we create the final models using all samples…\n\nGO_terms_auc_svm_final = {}\nGO_terms_aupr_svm_final = {}\nGO_terms_precision_svm_final = {}\nmodels_svm = {}\n\n# Perform logistics\nfor goterm in sparseGO_terms:\n    #print(goterm)\n    goterm_drugs = slim_matrix.loc[[goterm+\"_\"+str(1)]].values.flatten()\n    \n    if sum(goterm_drugs) <= 16:\n        continue\n\n    list_nodes = []\n    for i in range(1,7):\n        list_nodes.append(goterm+\"_\"+str(i))\n\n    score = attribution_data_annotated.loc[list_nodes].T\n    score_mod = score.divide(score.std()).fillna(0)\n    \n    X_train = score_mod\n    X_test = score_mod\n    y_train = goterm_drugs\n    y_test = goterm_drugs\n    \n    #gamma = 1/(X_train.shape[1]*X_train.to_numpy().var())\n    gamma=\"scale\"\n    C=1\n    \n    \n        \n    svm_model = svm.SVC(C=C,gamma=gamma, kernel='rbf',\n                           class_weight=\"balanced\",\n                            tol=0.001,\n                            probability=True,\n                           random_state=1234)\n    # fit the model with data\n    svm_model.fit(X_train,y_train)\n    y_pred=svm_model.predict(X_test)\n\n    #auc\n    y_pred_proba = svm_model.predict_proba(X_test)[::,1]  # platt values\n    #y_pred_proba = svm_model.decision_function(X_test)\n    \n    GO_terms_auc_svm_final[goterm] = metrics.roc_auc_score(y_test, y_pred_proba)\n\n    precision, recall, thresholds = metrics.precision_recall_curve(y_test, y_pred_proba)\n    GO_terms_aupr_svm_final[goterm] = metrics.auc(recall, precision)\n    GO_terms_precision_svm_final[goterm] = metrics.precision_score(y_test, y_pred)\n    models_svm[goterm]=svm_model\n\n\nlen(models_svm)\n\n1124\n\n\n\nFinal model AUC\n\nGO_terms_auc_svm_df_final = pd.DataFrame(list(GO_terms_auc_svm_final.items()),columns = ['goterm','auc']).set_index(\"goterm\")\nGO_terms_auc_svm_df_final = GO_terms_auc_svm_df_final.dropna()\nGO_terms_auc_svm_df_final.sort_values(by=[\"auc\"], ascending=False).head()\n\n\n\n\n\n  \n    \n      \n      auc\n    \n    \n      goterm\n      \n    \n  \n  \n    \n      GO:0030890\n      0.995511\n    \n    \n      GO:1901029\n      0.994437\n    \n    \n      GO:0051452\n      0.993673\n    \n    \n      GO:0030279\n      0.993469\n    \n    \n      GO:1901863\n      0.991582\n    \n  \n\n\n\n\n\nsns.set(rc={'figure.figsize':(6,4)})\nperc = str(round((100*len(GO_terms_auc_svm_df_final[GO_terms_auc_svm_df_final[\"auc\"]>0.7])/len(GO_terms_auc_svm_df_final)),2))+\"%\"\nN, bins, patches = plt.hist(GO_terms_auc_svm_df_final, color=CB_color_cycle[6],bins=50, linewidth=0.1)\n\nfor i in range(0,len(bins)-1):\n    if bins[i]>0.7:\n        patches[i].set_facecolor(CB_color_cycle[2])\n\nplt.xlabel(\"AUC (logistic 1)\", fontsize=16)  \nplt.title(perc, fontsize=16)\n# con el que mejor funciona es con la suma normal del attribution \n\nText(0.5, 1.0, '93.42%')\n\n\n\n\n\n\n\nFinal model AUPR\n\nGO_terms_aupr_svm_df_final = pd.DataFrame(list(GO_terms_aupr_svm_final.items()),columns = ['goterm','aupr']).set_index(\"goterm\")\nGO_terms_aupr_svm_df_final = GO_terms_aupr_svm_df_final.dropna()\nGO_terms_aupr_svm_df_final.sort_values(by=[\"aupr\"], ascending=False).head()\n\n\n\n\n\n  \n    \n      \n      aupr\n    \n    \n      goterm\n      \n    \n  \n  \n    \n      GO:0009058\n      0.974362\n    \n    \n      GO:0030890\n      0.965743\n    \n    \n      GO:0033033\n      0.965598\n    \n    \n      GO:0097345\n      0.960797\n    \n    \n      GO:0010467\n      0.959505\n    \n  \n\n\n\n\n\n# TENGO PROBLEMA CON EL RECALL \nsns.set(rc={'figure.figsize':(5,3)})\nperc = str(round((100*len(GO_terms_aupr_svm_df_final[GO_terms_aupr_svm_df_final[\"aupr\"]>0.7])/len(GO_terms_aupr_svm_df_final)),2))+\"%\"\nN, bins, patches = plt.hist(GO_terms_aupr_svm_df_final, color=CB_color_cycle[6],bins=50, linewidth=0.1)\nfor i in range(0,len(bins)-1):\n    if bins[i]>0.7:\n        patches[i].set_facecolor(CB_color_cycle[3])\n\nplt.xlabel(\"AUPR\", fontsize=16)  \nplt.title(perc, fontsize=16)\n\nText(0.5, 1.0, '23.31%')"
  },
  {
    "objectID": "DeepMoA.html#predict-for-a-new-drug",
    "href": "DeepMoA.html#predict-for-a-new-drug",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "Predict for a new drug",
    "text": "Predict for a new drug\n\nMake predictions\n\nunknown = list(set(attribution_data_all.columns)-set(attribution_data_annotated.columns))\n\nGet the probabilities for all unknown drugs\n\npredictions = {}\ndistances = {}\nprobabilities_unknown = pd.DataFrame()\npreds_unknown = pd.DataFrame()\n\nfor drug in unknown:\n    probabilities = {}\n    for goterm in models_svm.keys():\n\n        list_nodes = list(models_svm[goterm].feature_names_in_) # Extract the feature names from the model (those are the attributions we need)\n\n        score = attribution_data_all.loc[list_nodes][drug].to_frame().T \n        score_mod = score.divide(attribution_data_annotated.loc[list_nodes].T.std()).fillna(0) #divide by std of each neuron, only use drugs that trained the models\n\n        predictions[goterm]=models_svm[goterm].predict(score_mod)\n        probabilities[goterm] = models_svm[goterm].predict_proba(score_mod)[::,1]  # platt values\n        # distances[goterm] = models_svm[goterm].decision_function(score_mod)\n        \n    drug_probs = pd.DataFrame.from_dict(probabilities).T\n    drug_probs.columns = [drug]\n    drug_preds = pd.DataFrame.from_dict(predictions).T\n    drug_preds.columns = [drug]    \n    probabilities_unknown = pd.concat([probabilities_unknown,drug_probs], axis=1)\n    preds_unknown = pd.concat([preds_unknown,drug_preds], axis=1)\n    print(drug)\n\n\n\nStudy drug with unknown MOA\nChoose drug with unknown MOA…\n\ncombobox_u = interactive(f, drug=widgets.Combobox(options=unknown))\n\n\npredictions_nodes = []\nfor goterm in list(platt_matrix.index):\n    predictions_nodes.append(goterm+\"_\"+str(1))\n\n\n# add names to go terms\nreal_go_info_svm= real_go_info[real_go_info.GO_term.isin(predictions_nodes)]\nreal_go_info_svm.GO_term = real_go_info_svm.GO_term.str.replace(\"_1\",\"\")\n\n\ndisplay(combobox_u)\n\n\n\n\n\nselected_drug_u_name = combobox_u.result\n\n\npredictions_df = pd.DataFrame.from_dict(preds_unknown.loc[:,selected_drug_u_name]).reset_index()\npredictions_df.columns  = [\"GO_term\",\"predictions\"]\n\n\nprobabilities_df = pd.DataFrame.from_dict(probabilities_unknown.loc[:,selected_drug_u_name]).reset_index()\nprobabilities_df.columns  = [\"GO_term\",\"probability\"]\nprobabilities_df = probabilities_df.merge(real_go_info_svm, on=\"GO_term\")\nprobabilities_df = probabilities_df.merge(predictions_df, on=\"GO_term\")\nprobabilities_df.loc[probabilities_df[\"layer_number\"] <=3].sort_values(by=[\"probability\"], ascending=False).head(30)\n\n\n\n\n\n  \n    \n      \n      GO_term\n      probability\n      Name\n      layer_number\n      predictions\n    \n  \n  \n    \n      15\n      GO:0007051\n      0.775651\n      Spindle organization (1)\n      3.0\n      1.0\n    \n    \n      25\n      GO:0045930\n      0.728483\n      Negative regulation of mitotic cell cycle (1)\n      3.0\n      1.0\n    \n    \n      312\n      GO:0033033\n      0.668570\n      Negative regulation of myeloid cell apoptotic process (1)\n      0.0\n      1.0\n    \n    \n      85\n      GO:0001783\n      0.648156\n      B cell apoptotic process (1)\n      1.0\n      1.0\n    \n    \n      241\n      GO:0018105\n      0.645704\n      Peptidyl-serine phosphorylation (1)\n      2.0\n      1.0\n    \n    \n      579\n      GO:0031328\n      0.645487\n      Positive regulation of cellular biosynthetic process (1)\n      3.0\n      1.0\n    \n    \n      365\n      GO:0007098\n      0.597286\n      Centrosome cycle (1)\n      3.0\n      1.0\n    \n    \n      789\n      GO:1900118\n      0.562231\n      Negative regulation of execution phase of apoptosis (1)\n      0.0\n      1.0\n    \n    \n      444\n      GO:1901990\n      0.539374\n      Regulation of mitotic cell cycle phase transition (1)\n      3.0\n      1.0\n    \n    \n      636\n      GO:0042633\n      0.538572\n      Hair cycle (1)\n      2.0\n      1.0\n    \n    \n      73\n      GO:0071456\n      0.526585\n      Cellular response to hypoxia (1)\n      1.0\n      1.0\n    \n    \n      888\n      GO:1901988\n      0.526572\n      Negative regulation of cell cycle phase transition (1)\n      3.0\n      1.0\n    \n    \n      242\n      GO:0018107\n      0.515176\n      Peptidyl-threonine phosphorylation (1)\n      1.0\n      1.0\n    \n    \n      362\n      GO:0007030\n      0.511032\n      Golgi organization (1)\n      1.0\n      1.0\n    \n    \n      465\n      GO:0007517\n      0.510204\n      Muscle organ development (1)\n      3.0\n      1.0\n    \n    \n      532\n      GO:0010557\n      0.509768\n      Positive regulation of macromolecule biosynthetic process (1)\n      3.0\n      0.0\n    \n    \n      502\n      GO:0008284\n      0.500000\n      Positive regulation of cell population proliferation (1)\n      3.0\n      0.0\n    \n    \n      741\n      GO:0055001\n      0.500000\n      Muscle cell development (1)\n      3.0\n      1.0\n    \n    \n      795\n      GO:1902236\n      0.500000\n      Negative regulation of endoplasmic reticulum stress-induced intrinsic apoptotic signaling pathway (1)\n      0.0\n      1.0\n    \n    \n      233\n      GO:0045944\n      0.481732\n      Positive regulation of transcription by rna polymerase ii (1)\n      1.0\n      0.0\n    \n    \n      321\n      GO:2000811\n      0.478198\n      Negative regulation of anoikis (1)\n      0.0\n      1.0\n    \n    \n      227\n      GO:0006366\n      0.474951\n      Transcription by rna polymerase ii (1)\n      3.0\n      0.0\n    \n    \n      511\n      GO:0009410\n      0.466373\n      Response to xenobiotic stimulus (1)\n      3.0\n      1.0\n    \n    \n      776\n      GO:0072593\n      0.458202\n      Reactive oxygen species metabolic process (1)\n      3.0\n      1.0\n    \n    \n      78\n      GO:0001701\n      0.448882\n      In utero embryonic development (1)\n      3.0\n      1.0\n    \n    \n      177\n      GO:0007283\n      0.445234\n      Spermatogenesis (1)\n      3.0\n      1.0\n    \n    \n      319\n      GO:0097194\n      0.419988\n      Execution phase of apoptosis (1)\n      2.0\n      1.0\n    \n    \n      86\n      GO:0002903\n      0.417616\n      Negative regulation of b cell apoptotic process (1)\n      0.0\n      1.0\n    \n    \n      614\n      GO:0035094\n      0.412038\n      Response to nicotine (1)\n      1.0\n      1.0\n    \n    \n      1117\n      GO:2001243\n      0.409103\n      Negative regulation of intrinsic apoptotic signaling pathway (1)\n      2.0\n      1.0\n    \n  \n\n\n\n\n\nsum(probabilities_df[\"predictions\"] ==1)\n\n303\n\n\n\nsum(probabilities_df[\"predictions\"] ==0)\n\n821\n\n\nProbability < 0.5 doesn’t mean it does not belong to the class, a probability of for example 0.2 can represent a 1 (annotated to MoA)"
  },
  {
    "objectID": "DeepMoA.html#modify-probabilities",
    "href": "DeepMoA.html#modify-probabilities",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "Modify probabilities",
    "text": "Modify probabilities\nTake into account the annotations each GO term has (general GO terms are easier to predict as they have more annotations)\n\nFor drug with unknown MOA…\n\nsum_annotations = slim_matrix_single_neuron.T.sum()/slim_matrix_single_neuron.shape[1]\nlogits_apriori = np.log(sum_annotations/(1-sum_annotations))\n\nlogits_apost= np.log(probabilities_df[\"probability\"]/(1-probabilities_df[\"probability\"]))\ndelta_logits =logits_apost.to_numpy()- logits_apriori.to_numpy()\ndelta_logits_df = pd.DataFrame(delta_logits)\ndelta_logits_df.columns = [\"delta_logits\"]\nprobabilities_mod = probabilities_df.merge(delta_logits_df, left_index=True,right_index=True)\n\n\nprobabilities_mod.loc[probabilities_mod[\"predictions\"] ==1].loc[probabilities_mod[\"layer_number\"] <= 7].sort_values(by=[\"delta_logits\"], ascending=False).head(30)\n\n\n\n\n\n  \n    \n      \n      GO_term\n      probability\n      Name\n      layer_number\n      predictions\n      delta_logits\n    \n  \n  \n    \n      15\n      GO:0007051\n      0.775651\n      Spindle organization (1)\n      3.0\n      1.0\n      3.801391\n    \n    \n      312\n      GO:0033033\n      0.668570\n      Negative regulation of myeloid cell apoptotic process (1)\n      0.0\n      1.0\n      3.207249\n    \n    \n      85\n      GO:0001783\n      0.648156\n      B cell apoptotic process (1)\n      1.0\n      1.0\n      2.917688\n    \n    \n      789\n      GO:1900118\n      0.562231\n      Negative regulation of execution phase of apoptosis (1)\n      0.0\n      1.0\n      2.811113\n    \n    \n      364\n      GO:0007059\n      0.651932\n      Chromosome segregation (1)\n      5.0\n      1.0\n      2.648874\n    \n    \n      25\n      GO:0045930\n      0.728483\n      Negative regulation of mitotic cell cycle (1)\n      3.0\n      1.0\n      2.600911\n    \n    \n      795\n      GO:1902236\n      0.500000\n      Negative regulation of endoplasmic reticulum stress-induced intrinsic apoptotic signaling pathway (1)\n      0.0\n      1.0\n      2.560893\n    \n    \n      365\n      GO:0007098\n      0.597286\n      Centrosome cycle (1)\n      3.0\n      1.0\n      2.530027\n    \n    \n      362\n      GO:0007030\n      0.511032\n      Golgi organization (1)\n      1.0\n      1.0\n      2.350877\n    \n    \n      376\n      GO:0098813\n      0.474213\n      Nuclear chromosome segregation (1)\n      4.0\n      1.0\n      2.073193\n    \n    \n      762\n      GO:0070925\n      0.703152\n      Organelle assembly (1)\n      4.0\n      1.0\n      2.069600\n    \n    \n      903\n      GO:0072384\n      0.336307\n      Organelle transport along microtubule (1)\n      2.0\n      1.0\n      2.000421\n    \n    \n      86\n      GO:0002903\n      0.417616\n      Negative regulation of b cell apoptotic process (1)\n      0.0\n      1.0\n      1.974177\n    \n    \n      370\n      GO:0045786\n      0.624233\n      Negative regulation of cell cycle (1)\n      5.0\n      1.0\n      1.917603\n    \n    \n      367\n      GO:0010948\n      0.603975\n      Negative regulation of cell cycle process (1)\n      4.0\n      1.0\n      1.905513\n    \n    \n      1058\n      GO:2000669\n      0.341573\n      Negative regulation of dendritic cell apoptotic process (1)\n      0.0\n      1.0\n      1.796355\n    \n    \n      1056\n      GO:0070233\n      0.356845\n      Negative regulation of t cell apoptotic process (1)\n      1.0\n      1.0\n      1.764358\n    \n    \n      839\n      GO:1902166\n      0.329441\n      Negative regulation of intrinsic apoptotic signaling pathway in response to dna damage by p53 class mediator (1)\n      0.0\n      1.0\n      1.741929\n    \n    \n      368\n      GO:0032465\n      0.382860\n      Regulation of cytokinesis (1)\n      2.0\n      1.0\n      1.740942\n    \n    \n      321\n      GO:2000811\n      0.478198\n      Negative regulation of anoikis (1)\n      0.0\n      1.0\n      1.731163\n    \n    \n      319\n      GO:0097194\n      0.419988\n      Execution phase of apoptosis (1)\n      2.0\n      1.0\n      1.698511\n    \n    \n      16\n      GO:0031023\n      0.312643\n      Microtubule organizing center organization (1)\n      4.0\n      1.0\n      1.664852\n    \n    \n      888\n      GO:1901988\n      0.526572\n      Negative regulation of cell cycle phase transition (1)\n      3.0\n      1.0\n      1.640736\n    \n    \n      636\n      GO:0042633\n      0.538572\n      Hair cycle (1)\n      2.0\n      1.0\n      1.613210\n    \n    \n      994\n      GO:1900182\n      0.296416\n      Positive regulation of protein localization to nucleus (1)\n      1.0\n      1.0\n      1.537597\n    \n    \n      965\n      GO:0030705\n      0.274210\n      Cytoskeleton-dependent intracellular transport (1)\n      4.0\n      1.0\n      1.532160\n    \n    \n      977\n      GO:0031648\n      0.261530\n      Protein destabilization (1)\n      0.0\n      1.0\n      1.522862\n    \n    \n      289\n      GO:0032469\n      0.301677\n      Endoplasmic reticulum calcium ion homeostasis (1)\n      1.0\n      1.0\n      1.514119\n    \n    \n      465\n      GO:0007517\n      0.510204\n      Muscle organ development (1)\n      3.0\n      1.0\n      1.499437\n    \n    \n      614\n      GO:0035094\n      0.412038\n      Response to nicotine (1)\n      1.0\n      1.0\n      1.494658\n    \n  \n\n\n\n\n\nnames2 = list(probabilities_mod.loc[probabilities_mod[\"predictions\"] ==1].loc[probabilities_mod[\"layer_number\"] <=7].sort_values(by=[\"delta_logits\"], ascending=False)[\"Name\"].head(30))\nterms2 = list(probabilities_mod.loc[probabilities_mod[\"predictions\"] ==1].loc[probabilities_mod[\"layer_number\"] <=7].sort_values(by=[\"delta_logits\"], ascending=False)[\"GO_term\"].head(30))\nlogits2 = list(probabilities_mod.loc[probabilities_mod[\"predictions\"] ==1].loc[probabilities_mod[\"layer_number\"] <=7].sort_values(by=[\"delta_logits\"], ascending=False)[\"delta_logits\"].head(30))\n\nnames2 = [x[:-4] for x in names2] \n\n\nfor i in range(0,len(names2)):\n    print(terms2[i],names2[i],logits2[i])\n\nGO:0007051 Spindle organization 3.801390702868236\nGO:0033033 Negative regulation of myeloid cell apoptotic process 3.2072492134319956\nGO:0001783 B cell apoptotic process 2.9176875271685683\nGO:1900118 Negative regulation of execution phase of apoptosis 2.8111130136057216\nGO:0007059 Chromosome segregation 2.64887443203506\nGO:0045930 Negative regulation of mitotic cell cycle 2.6009108234102625\nGO:1902236 Negative regulation of endoplasmic reticulum stress-induced intrinsic apoptotic signaling pathway 2.5608925567659226\nGO:0007098 Centrosome cycle 2.530026738008422\nGO:0007030 Golgi organization 2.3508774173095186\nGO:0098813 Nuclear chromosome segregation 2.0731926893576196\nGO:0070925 Organelle assembly 2.069600192282952\nGO:0072384 Organelle transport along microtubule 2.0004213788686807\nGO:0002903 Negative regulation of b cell apoptotic process 1.9741768883148958\nGO:0045786 Negative regulation of cell cycle 1.917603030826096\nGO:0010948 Negative regulation of cell cycle process 1.9055131265535517\nGO:2000669 Negative regulation of dendritic cell apoptotic process 1.7963554850648258\nGO:0070233 Negative regulation of t cell apoptotic process 1.7643576360799753\nGO:1902166 Negative regulation of intrinsic apoptotic signaling pathway in response to dna damage by p53 class mediator 1.7419293617961054\nGO:0032465 Regulation of cytokinesis 1.7409418248944983\nGO:2000811 Negative regulation of anoikis 1.7311634175406592\nGO:0097194 Execution phase of apoptosis 1.6985112888037164\nGO:0031023 Microtubule organizing center organization 1.6648522832794037\nGO:1901988 Negative regulation of cell cycle phase transition 1.640735739239383\nGO:0042633 Hair cycle 1.6132096412865522\nGO:1900182 Positive regulation of protein localization to nucleus 1.5375973554160984\nGO:0030705 Cytoskeleton-dependent intracellular transport 1.5321597954461827\nGO:0031648 Protein destabilization 1.5228619022250793\nGO:0032469 Endoplasmic reticulum calcium ion homeostasis 1.5141189889858477\nGO:0007517 Muscle organ development 1.499437003178439\nGO:0035094 Response to nicotine 1.494657812504115\n\n\n\n# import libraries\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n%matplotlib inline\n\n# set font\nplt.rcParams['font.family'] = 'sans-serif'\nplt.rcParams['font.sans-serif'] = 'Roboto'\n\n# set the style of the axes and the text color\nplt.rcParams['axes.edgecolor']='#333F4B'\nplt.rcParams['axes.linewidth']=0.8\nplt.rcParams['xtick.color']='#333F4B'\nplt.rcParams['ytick.color']='#333F4B'\nplt.rcParams['text.color']='#333F4B'\n\n\n# create some fake data\npercentages = pd.Series(logits2, \n                        index=[s.title() for s in names2])\ndf = pd.DataFrame({'percentage' : percentages})\ndf = df.sort_values(by='percentage')\n\n# we first need a numeric placeholder for the y axis\nmy_range=list(range(1,len(df.index)+1))\n\nfig, ax = plt.subplots(figsize=(4,17))\n\n# create for each expense type an horizontal line that starts at x = 0 with the length \n# represented by the specific value.\nplt.hlines(y=my_range, xmin=0, xmax=df['percentage'], color='#208EA3', alpha=0.2, linewidth=14)\n\n# create for each value type a dot at the level of the value\nplt.plot(df['percentage'], my_range, \"o\", markersize=14, color='#208EA3', alpha=0.8)\n\n# set labels\nax.set_xlabel(' Δlogit', fontsize=25, fontweight='black', color = '#36382E')\nax.set_ylabel('')\nax.set_facecolor(color=\"white\")\nax.set_alpha(1)\n\n# set axis\nax.tick_params(axis='both', which='major', labelsize=32)\nplt.yticks(my_range, df.index)\n\n# add an horizonal label for the y axis \nfig.text(-0.58, 0.862, 'MoA (GO terms)', fontsize=27, fontweight='black', color = '#36382E')\nfig.text(0.2, 0.9, selected_drug_u_name.capitalize(), fontsize=32, fontweight='black', color = '#36382E')\n\n# .upper() capitalize\n\n# change the style of the axis spines\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\n\nax.spines['left'].set_bounds((1, len(my_range)))\nax.set_xlim(0,max(logits2)+0.1)\n\nax.spines['left'].set_position(('outward', 8))\nax.spines['bottom'].set_position(('outward', 5))\n\nplt.savefig(resultsdir+selected_drug_u_name+'_top_terms.png', dpi=300, bbox_inches='tight')\n\n\n\n\n\n\nFor known drug…\n\ndisplay(combobox)\n\n\n\n\n\nselected_drug_name = combobox.result\n\n\n# LOS LOGITS DE TEST!!\ntrain_drug_logs = pd.DataFrame(platt_matrix.loc[:,selected_drug_name]).reset_index()\ntrain_drug_logs.columns  = [\"GO_term\",\"probability\"]\ntrain_drug_logs = train_drug_logs.merge(real_go_info_svm, on=\"GO_term\")\n\n\ntrain_drug_logs.loc[train_drug_logs[\"layer_number\"] <=3].sort_values(by=[\"probability\"], ascending=False).head(30)\n\n\n\n\n\n  \n    \n      \n      GO_term\n      probability\n      Name\n      layer_number\n    \n  \n  \n    \n      183\n      GO:0048608\n      0.742225\n      Reproductive structure development (1)\n      3.0\n    \n    \n      381\n      GO:0048041\n      0.737675\n      Focal adhesion assembly (1)\n      2.0\n    \n    \n      535\n      GO:0010628\n      0.646147\n      Positive regulation of gene expression (1)\n      3.0\n    \n    \n      181\n      GO:0045137\n      0.645515\n      Development of primary sexual characteristics (1)\n      3.0\n    \n    \n      329\n      GO:0006939\n      0.637615\n      Smooth muscle contraction (1)\n      3.0\n    \n    \n      532\n      GO:0010557\n      0.628009\n      Positive regulation of macromolecule biosynthetic process (1)\n      3.0\n    \n    \n      579\n      GO:0031328\n      0.620431\n      Positive regulation of cellular biosynthetic process (1)\n      3.0\n    \n    \n      408\n      GO:0048008\n      0.615540\n      Platelet-derived growth factor receptor signaling pathway (1)\n      1.0\n    \n    \n      502\n      GO:0008284\n      0.594571\n      Positive regulation of cell population proliferation (1)\n      3.0\n    \n    \n      776\n      GO:0072593\n      0.591717\n      Reactive oxygen species metabolic process (1)\n      3.0\n    \n    \n      558\n      GO:0021700\n      0.587295\n      Developmental maturation (1)\n      3.0\n    \n    \n      192\n      GO:0003254\n      0.571930\n      Regulation of membrane depolarization (1)\n      1.0\n    \n    \n      869\n      GO:1902533\n      0.567760\n      Positive regulation of intracellular signal transduction (1)\n      3.0\n    \n    \n      144\n      GO:0002318\n      0.544781\n      Myeloid progenitor cell differentiation (1)\n      0.0\n    \n    \n      120\n      GO:0045860\n      0.539516\n      Positive regulation of protein kinase activity (1)\n      3.0\n    \n    \n      741\n      GO:0055001\n      0.538092\n      Muscle cell development (1)\n      3.0\n    \n    \n      10\n      GO:0043410\n      0.531527\n      Positive regulation of mapk cascade (1)\n      2.0\n    \n    \n      133\n      GO:0061138\n      0.520278\n      Morphogenesis of a branching epithelium (1)\n      3.0\n    \n    \n      527\n      GO:0010035\n      0.514162\n      Response to inorganic substance (1)\n      3.0\n    \n    \n      1040\n      GO:0042113\n      0.509569\n      B cell activation (1)\n      3.0\n    \n    \n      595\n      GO:0032526\n      0.508940\n      Response to retinoic acid (1)\n      1.0\n    \n    \n      164\n      GO:0030183\n      0.500000\n      B cell differentiation (1)\n      2.0\n    \n    \n      793\n      GO:1901888\n      0.500000\n      Regulation of cell junction assembly (1)\n      2.0\n    \n    \n      1045\n      GO:0051899\n      0.500000\n      Membrane depolarization (1)\n      2.0\n    \n    \n      406\n      GO:0038084\n      0.491700\n      Vascular endothelial growth factor signaling pathway (1)\n      1.0\n    \n    \n      227\n      GO:0006366\n      0.489305\n      Transcription by rna polymerase ii (1)\n      3.0\n    \n    \n      42\n      GO:0001503\n      0.478874\n      Ossification (1)\n      3.0\n    \n    \n      12\n      GO:0070371\n      0.477843\n      Erk1 and erk2 cascade (1)\n      2.0\n    \n    \n      64\n      GO:0001656\n      0.476283\n      Metanephros development (1)\n      3.0\n    \n    \n      1022\n      GO:0048015\n      0.460363\n      Phosphatidylinositol-mediated signaling (1)\n      3.0\n    \n  \n\n\n\n\n\nax = sns.boxplot(x=slim_matrix_single_neuron.loc[train_drug_logs[\"GO_term\"],selected_drug_name], y=train_drug_logs.set_index(\"GO_term\")[\"probability\"], data=plot,showfliers=True )\n\n\n\n\n\n# same as before\nsum_annotations = slim_matrix_single_neuron.T.sum()/slim_matrix_single_neuron.shape[1]\nlogits_apriori= np.log(sum_annotations/(1-sum_annotations))\n\n\nlogits_apost= np.log(train_drug_logs[\"probability\"]/(1-train_drug_logs[\"probability\"]))\ndelta_logits = logits_apost.to_numpy()-logits_apriori.to_numpy()\ndelta_logits_df = pd.DataFrame(delta_logits)\ndelta_logits_df.columns = [\"delta_logits\"]\ntrain_drug_mod = train_drug_logs.merge(delta_logits_df, left_index=True,right_index=True)\n\n\ntrain_drug_mod.loc[train_drug_mod[\"layer_number\"] <=3].sort_values(by=[\"delta_logits\"], ascending=False).head(30)\n\n\n\n\n\n  \n    \n      \n      GO_term\n      probability\n      Name\n      layer_number\n      delta_logits\n    \n  \n  \n    \n      329\n      GO:0006939\n      0.637615\n      Smooth muscle contraction (1)\n      3.0\n      2.871769\n    \n    \n      381\n      GO:0048041\n      0.737675\n      Focal adhesion assembly (1)\n      2.0\n      2.568268\n    \n    \n      144\n      GO:0002318\n      0.544781\n      Myeloid progenitor cell differentiation (1)\n      0.0\n      2.533049\n    \n    \n      408\n      GO:0048008\n      0.615540\n      Platelet-derived growth factor receptor signaling pathway (1)\n      1.0\n      2.529048\n    \n    \n      595\n      GO:0032526\n      0.508940\n      Response to retinoic acid (1)\n      1.0\n      2.437785\n    \n    \n      183\n      GO:0048608\n      0.742225\n      Reproductive structure development (1)\n      3.0\n      2.222701\n    \n    \n      458\n      GO:0048839\n      0.391941\n      Inner ear development (1)\n      3.0\n      2.066365\n    \n    \n      793\n      GO:1901888\n      0.500000\n      Regulation of cell junction assembly (1)\n      2.0\n      2.058388\n    \n    \n      956\n      GO:0002327\n      0.382026\n      Immature b cell differentiation (1)\n      0.0\n      1.921062\n    \n    \n      192\n      GO:0003254\n      0.571930\n      Regulation of membrane depolarization (1)\n      1.0\n      1.903704\n    \n    \n      181\n      GO:0045137\n      0.645515\n      Development of primary sexual characteristics (1)\n      3.0\n      1.806630\n    \n    \n      1029\n      GO:0035909\n      0.293492\n      Aorta morphogenesis (1)\n      1.0\n      1.801732\n    \n    \n      1118\n      GO:0097530\n      0.339315\n      Granulocyte migration (1)\n      3.0\n      1.786297\n    \n    \n      24\n      GO:0045840\n      0.365727\n      Positive regulation of mitotic nuclear division (1)\n      1.0\n      1.756150\n    \n    \n      65\n      GO:0072075\n      0.273943\n      Metanephric mesenchyme development (1)\n      0.0\n      1.705507\n    \n    \n      958\n      GO:0045580\n      0.389135\n      Regulation of t cell differentiation (1)\n      3.0\n      1.684905\n    \n    \n      406\n      GO:0038084\n      0.491700\n      Vascular endothelial growth factor signaling pathway (1)\n      1.0\n      1.636301\n    \n    \n      474\n      GO:0007585\n      0.259741\n      Respiratory gaseous exchange by respiratory system (1)\n      2.0\n      1.632898\n    \n    \n      936\n      GO:0035584\n      0.282146\n      Calcium-mediated signaling using intracellular calcium source (1)\n      0.0\n      1.627051\n    \n    \n      776\n      GO:0072593\n      0.591717\n      Reactive oxygen species metabolic process (1)\n      3.0\n      1.621405\n    \n    \n      479\n      GO:0050910\n      0.256674\n      Detection of mechanical stimulus involved in sensory perception of sound (1)\n      0.0\n      1.616889\n    \n    \n      961\n      GO:0055003\n      0.261761\n      Cardiac myofibril assembly (1)\n      0.0\n      1.582183\n    \n    \n      741\n      GO:0055001\n      0.538092\n      Muscle cell development (1)\n      3.0\n      1.562711\n    \n    \n      558\n      GO:0021700\n      0.587295\n      Developmental maturation (1)\n      3.0\n      1.560039\n    \n    \n      609\n      GO:0034103\n      0.287738\n      Regulation of tissue remodeling (1)\n      1.0\n      1.546250\n    \n    \n      1045\n      GO:0051899\n      0.500000\n      Membrane depolarization (1)\n      2.0\n      1.534347\n    \n    \n      590\n      GO:0032355\n      0.380108\n      Response to estradiol (1)\n      1.0\n      1.532244\n    \n    \n      129\n      GO:0051894\n      0.341633\n      Positive regulation of focal adhesion assembly (1)\n      0.0\n      1.520410\n    \n    \n      64\n      GO:0001656\n      0.476283\n      Metanephros development (1)\n      3.0\n      1.492026\n    \n    \n      428\n      GO:0007266\n      0.373714\n      Rho protein signal transduction (1)\n      2.0\n      1.468985\n    \n  \n\n\n\n\n\nax = sns.boxplot(x=slim_matrix_single_neuron.loc[train_drug_mod[\"GO_term\"],selected_drug_name], y=train_drug_mod.set_index(\"GO_term\")[\"delta_logits\"], data=plot,showfliers=True)"
  },
  {
    "objectID": "DeepMoA.html#svm-go-term-2d-representation",
    "href": "DeepMoA.html#svm-go-term-2d-representation",
    "title": "DeepMoA: method to predict the mechanism of action of cancer drugs",
    "section": "SVM GO TERM 2D representation",
    "text": "SVM GO TERM 2D representation\n\nfrom sklearn.manifold import TSNE\nimport plotly.express as px\n\nChoose go to study…\n\ndisplay(combobox_go)\n\n\n\n\n\nselected_goterm = combobox_go.result\n\n\nreal_go_info[real_go_info[\"GO_term\"]==selected_goterm+\"_1\"]\n\n\n\n\n\n  \n    \n      \n      GO_term\n      Name\n      layer_number\n    \n  \n  \n    \n      24\n      GO:0007051_1\n      Spindle organization (1)\n      3.0\n    \n  \n\n\n\n\n\nlist_nodes = []\nfor i in range(1,7):\n    list_nodes.append(selected_goterm+\"_\"+str(i))\n\nscore = attribution_data_annotated.loc[list_nodes].T\nscore_mod = score.divide(score.std()).fillna(0) \nannotations  =slim_matrix_single_neuron.loc[selected_goterm,]\ny_predicted = models_svm[selected_goterm].predict(score_mod.astype(float))\n\n\nPlot SVM\n\nView statistics of GOterm\n“Perfect” model (with train data)\n\nauc = metrics.roc_auc_score(annotations, models_svm[selected_goterm].decision_function(score_mod.astype(float)))\ncnf_matrix = metrics.confusion_matrix(annotations,y_predicted)\nprint(cnf_matrix)\n\nprint(\"Accuracy:\",metrics.accuracy_score(annotations, y_predicted))\nprint(\"Precision:\",metrics.precision_score(annotations,y_predicted)) # TP / (TP+FP)\nprint(\"Recall:\",metrics.recall_score(annotations, y_predicted)) #TP / (TP+FN)\nprint(\"AUC with score:\",auc) \n\n[[227  19]\n [  3  16]]\nAccuracy: 0.9169811320754717\nPrecision: 0.45714285714285713\nRecall: 0.8421052631578947\nAUC with score: 0.9531450577663672\n\n\nTN - FP\nFN - TP\nEn mi opinion interesa mucho el precision, prefiero que haya menos FP no??\nTest statistics…\n\nauc = metrics.roc_auc_score(slim_matrix_single_neuron.loc[selected_goterm],  platt_matrix.loc[selected_goterm])\ncnf_matrix = metrics.confusion_matrix(slim_matrix_single_neuron.loc[selected_goterm], preds_svm_matrix.loc[selected_goterm])\nprint(cnf_matrix)\n\nprint(\"Accuracy:\",metrics.accuracy_score(slim_matrix_single_neuron.loc[selected_goterm], preds_svm_matrix.loc[selected_goterm]))\nprint(\"Precision:\",metrics.precision_score(slim_matrix_single_neuron.loc[selected_goterm], preds_svm_matrix.loc[selected_goterm]))\nprint(\"Recall:\",metrics.recall_score(slim_matrix_single_neuron.loc[selected_goterm], preds_svm_matrix.loc[selected_goterm])) #TP / (TP+FN)\nprint(\"AUC with score:\",auc) #TP / (TP+FN)\n\n[[225  21]\n [  6  13]]\nAccuracy: 0.8981132075471698\nPrecision: 0.38235294117647056\nRecall: 0.6842105263157895\nAUC with score: 0.891313649978605\n\n\n\nimport colorlover as cl\nmatrix = metrics.confusion_matrix(annotations,y_predicted)\ntn, fp, fn, tp = matrix.ravel()\n\nvalues = [tp, fn, fp, tn]\nlabel_text = [\"True Positive\", \"False Negative\", \"False Positive\", \"True Negative\"]\nlabels = [\"<b>TP</b>\", \"<b>FN</b>\", \"<b>FP</b>\", \"<b>TN</b>\"]\nblue = cl.flipper()[\"seq\"][\"9\"][\"Blues\"]\nred = cl.flipper()[\"seq\"][\"9\"][\"Reds\"]\ncolors = [\"#ff3700\",\"#FFA0A0\", \"#CCE9FF\",  \"#0b8bff\"]\ntrace0 = go.Pie(\n    labels=label_text,\n    values=values,\n    hoverinfo=\"label+value+percent\",\n    textinfo=\"text+value\",\n    text=labels,\n    sort=False,\n    marker=dict(colors=colors),\n    insidetextfont={\"color\": \"#36382E\"},\n    rotation=90,\n)\n\nlayout = go.Layout(\n    title=dict(text=\"Confusion Matrix\",\n              x=0.3,\n              y=0.8,\n              font=dict(size=14),\n              xanchor='center',\n              yanchor='top'),\n    #margin=dict(l=50, r=50, t=100, b=10),\n    legend=dict(font={\"color\": \"#36382E\"}, orientation=\"h\",x=0.1, y=-0.03),\n#    plot_bgcolor=\"#282b38\",\n#    paper_bgcolor=\"#282b38\",\n    font=dict(family='Roboto',color= \"#36382E\"),\n)\n\ndata = [trace0]\nfigure = go.Figure(data=data, layout=layout)\nfigure\n\n\n                                                \n\n\n\ny_test=annotations\ndecision_test=y_predicted\nfpr, tpr, threshold = metrics.roc_curve(y_test, decision_test)\n\n# AUC Score\nauc_score = metrics.roc_auc_score(y_true=y_test, y_score=decision_test)\n\ntrace0 = go.Scatter(\n    x=fpr, y=tpr, mode=\"lines\", name=\"Test Data\", marker={\"color\": \"#ff3700\"}\n)\n\nlayout = go.Layout(\n    title=dict(text=f\"ROC Curve (AUC = {auc_score:.3f})\",\n            x=0.6,\n            y=0.5,\n            font=dict(size=20)\n              ),\n    xaxis=dict(title=\"False Positive Rate\", gridcolor=\"white\"),\n    yaxis=dict(title=\"True Positive Rate\", gridcolor=\"white\"),\n    legend=dict(x=0, y=1.05, orientation=\"h\"),\n    margin=dict(l=100, r=10, t=25, b=40),\n#    plot_bgcolor=\"#282b38\",\n#    paper_bgcolor=\"#282b38\",\n    font=dict(family='Roboto',color= \"#36382E\"),\n)\n\ndata = [trace0]\nfigure = go.Figure(data=data, layout=layout)\nfigure\n\n\n                                                \n\n\n\n\nPlot SVM with unknown labels\n\nVoronoi Tessellation\nWhat is a Voronoi Tessellation? Given a set P := {p1, …, pn} of sites, a Voronoi Tessellation is a subdivision of the space into n cells, one for each site in P, with the property that a point q lies in the cell corresponding to a site pi iff d(pi, q) < d(pj, q) for i distinct from j. The segments in a Voronoi Tessellation correspond to all points in the plane equidistant to the two nearest sites. Voronoi Tessellations have applications in computer science.\nhttps://stackoverflow.com/questions/61225052/svm-plot-decision-surface-when-working-with-more-than-2-features\n\ntsne = TSNE(n_components=2, verbose=0,\n           init=\"pca\",\n            perplexity=30,\n            random_state=123\n           )\nz = tsne.fit_transform(score_mod.astype(float)) \n\n\nlist_nodes = list(models_svm[selected_goterm].feature_names_in_) # Extract the feature names from the model (those are the attributions we need)\nscore_unknown = attribution_data_all.loc[list_nodes,unknown].T\nscore_unknown_mod = score_unknown.divide(score.std()).fillna(0) # normalize\n\n\ny_unknown = np.full(score_unknown_mod.shape[0],2) # 2=unknown MOA\ny_pred_unknown = models_svm[selected_goterm].predict(score_unknown_mod.astype(float))\n\n\n# join scores and annotations from known and unknown drugs\nall_score = pd.concat([score_mod,score_unknown_mod])\nall_y = np.concatenate((annotations,y_unknown))  # 2=unknown MOA\n\nPlot T-SNE SVM\n\nfrom sklearn.neighbors._classification import KNeighborsClassifier\n# https://github.com/plotly/dash-sample-apps/blob/main/apps/dash-svm/utils/dash_reusable_components.py\nz = tsne.fit_transform(all_score.astype(float)) \ndf = pd.DataFrame()\ndf[\"y\"] = all_y\ndf[\"comp-1\"] = z[:,0]\ndf[\"comp-2\"] = z[:,1]\ndf[\"name\"] =list(all_score.index)\ndf = df.sort_values(by=['y'])\ndf[\"y\"] = df[\"y\"].astype(str)\nX,y = all_score.astype(float), all_y\ny_predicted = models_svm[selected_goterm].predict(X)\n\nresolution = 300 # 100x100 background pixels\nX2d_xmin, X2d_xmax = np.min(z[:,0])-1, np.max(z[:,0])+1\nX2d_ymin, X2d_ymax = np.min(z[:,1])-1, np.max(z[:,1])+1\nxx, yy = np.meshgrid(np.linspace(X2d_xmin, X2d_xmax, resolution), np.linspace(X2d_ymin, X2d_ymax, resolution))\n\n# approximate Voronoi tesselation on resolution x resolution grid using 1-NN\nbackground_model = KNeighborsClassifier(n_neighbors=1).fit(z, y_predicted) \nvoronoiBackground = background_model.predict(np.c_[xx.ravel(), yy.ravel()])\nvoronoiBackground = voronoiBackground.reshape((resolution, resolution))\n\n\ngo_name=real_go_info[real_go_info[\"GO_term\"]==selected_goterm+\"_1\"][\"Name\"].values[0][:-4]\ngo_name\n\n'Spindle organization'\n\n\n\nbright_cscale = [[0, \"#0b8bff\"], [0.5, \"#ff3700\"],[1, \"#36382E\"]]\nnew_cscale = [[0, \"#CCE9FF\"], [1, \"#FFA0A0\"]]\n\ntrace0 = go.Contour(\n        x=xx.flatten(),\n        y=yy.flatten(),\n        z=voronoiBackground.flatten(),\n        hoverinfo=\"none\",\n        showscale=False,\n        contours=dict(showlines=False),\n        colorscale=new_cscale,\n        opacity=0.9,\n    )\n    \ntrace1 = go.Contour(\n    x=xx.flatten(),\n    y=yy.flatten(),\n    z=voronoiBackground.flatten(),\n    showscale=False,\n    hoverinfo=\"none\",\n    colorscale=new_cscale,\n    line=dict(color=\"#ff3700\"),\n    )\n\ntrace2 = go.Scatter(\n    x=df[\"comp-1\"],\n    y=df[\"comp-2\"],\n    mode=\"markers\",\n    text=df[\"name\"].to_numpy(),\n    marker=dict(size=7, color=df[\"y\"].to_numpy(int),colorscale=bright_cscale),\n    showlegend=False\n)\n\nlegend1 = go.Scatter(\n    x=[None],\n    y=[None],\n    mode=\"markers\",\n    name=\"Not annotated<br>to \"+selected_goterm,\n    marker=dict(size=7, color=\"#0b8bff\",symbol='circle'),\n)\n\nlegend2 = go.Scatter(\n    x=[None],\n    y=[None],\n    mode=\"markers\",\n    name=\"Drug annotated<br>to \"+selected_goterm,\n    marker=dict(size=7, color=\"#ff3700\",symbol='circle'),\n)\n\nlegend3 = go.Scatter(\n    x=[None],\n    y=[None],\n    mode=\"markers\",\n    name=\"Unknown MOA<br>annotations\",\n    marker=dict(size=7, color=\"#36382E\",symbol='circle'),\n)\n\n    \nlayout = go.Layout(\n   title=dict(text=\"<b>\"+selected_goterm+\"</b> \"+go_name,\n              x=0.5,\n              y=0.92,\n              font=dict(size=23),\n              xanchor='center',\n              yanchor='top'),\n    xaxis=dict(ticks=\"\", showticklabels=False, showgrid=False, zeroline=False),\n    yaxis=dict(ticks=\"\", showticklabels=False, showgrid=False, zeroline=False),\n    yaxis_range=[min(yy.flatten()),max(yy.flatten())],\n    xaxis_range=[min(xx.flatten()),max(xx.flatten())],\n    legend=dict(x=0, y=0, orientation=\"h\",font=dict(size=15)),\n    paper_bgcolor='rgba(0,0,0,0)',\n    width=600, height=800,\n    font=dict(family='Roboto',color= \"#36382E\",size=15)\n    )\ndata = [trace0,trace1,trace2,legend2,legend1,legend3]\nfigure = go.Figure(data=data,layout=layout)\n\nfigure\n\n\n                                                \n\n\nAdd drugs\n\n# Spindle organization\nfigure = go.Figure(data=data,layout=layout)\nfigure.add_annotation(\n         x=df[\"comp-1\"].loc[df[\"name\"]==\"sb-743921\"].to_numpy()[0], y=df[\"comp-2\"].loc[df[\"name\"]==\"sb-743921\"].to_numpy()[0],\n         xref=\"x\", yref=\"y\",\n         text=\"<b>\"+'SB-743921'\"<b>\",\n         showarrow=True,\n         font=dict(\n            # family=\"Courier New, monospace\",\n             size=19,\n             color=\"#000000\"\n             ),\n         align=\"center\",\n         arrowhead=2,\n         arrowsize=1,\n         arrowwidth=2,\n         arrowcolor=\"#636363\",\n         ax=-250,\n         ay=-10,\n         bordercolor=\"#636363\",\n         borderwidth=1,\n         borderpad=4,\n         bgcolor=\"#ffffff\",\n         opacity=0.8\n         )\n\nfigure.add_annotation(\n         x=df[\"comp-1\"].loc[df[\"name\"]==\"thapsigargin\"].to_numpy()[0], y=df[\"comp-2\"].loc[df[\"name\"]==\"thapsigargin\"].to_numpy()[0],\n         xref=\"x\", yref=\"y\",\n         text=\"<b>\"+'Thapsigargin'\"<b>\",\n         showarrow=True,\n         font=dict(\n            # family=\"Courier New, monospace\",\n             size=19,\n             color=\"#000000\"\n             ),\n         align=\"center\",\n         arrowhead=2,\n         arrowsize=1,\n         arrowwidth=2,\n         arrowcolor=\"#636363\",\n         ax=-60,\n         ay=-90,\n         bordercolor=\"#636363\",\n         borderwidth=1,\n         borderpad=4,\n         bgcolor=\"#ffffff\",\n         opacity=0.8\n         )\n\nfigure.add_annotation(\n         x=df[\"comp-1\"].loc[df[\"name\"]==\"triptolide\"].to_numpy()[0], y=df[\"comp-2\"].loc[df[\"name\"]==\"triptolide\"].to_numpy()[0],\n         xref=\"x\", yref=\"y\",\n         text=\"<b>\"+'Triptolide'\"<b>\",\n         showarrow=True,\n         font=dict(\n            # family=\"Courier New, monospace\",\n             size=19,\n             color=\"#000000\"\n             ),\n         align=\"center\",\n         arrowhead=2,\n         arrowsize=1,\n         arrowwidth=2,\n         arrowcolor=\"#636363\",\n         ax=-130,\n         ay=-80,\n         bordercolor=\"#636363\",\n         borderwidth=1,\n         borderpad=4,\n         bgcolor=\"#ffffff\",\n         opacity=0.8\n         )\n\nfigure.add_annotation(\n         x=df[\"comp-1\"].loc[df[\"name\"]==\"gw843682x\"].to_numpy()[0], y=df[\"comp-2\"].loc[df[\"name\"]==\"gw843682x\"].to_numpy()[0],\n         xref=\"x\", yref=\"y\",\n         text=\"<b>\"+'GW843682X'\"<b>\",\n         showarrow=True,\n         font=dict(\n            # family=\"Courier New, monospace\",\n             size=19,\n             color=\"#000000\"\n             ),\n         align=\"center\",\n         arrowhead=2,\n         arrowsize=1,\n         arrowwidth=2,\n         arrowcolor=\"#636363\",\n         ax=-110,\n         ay=70,\n         bordercolor=\"#636363\",\n         borderwidth=1,\n         borderpad=4,\n         bgcolor=\"#ffffff\",\n         opacity=0.8\n         )"
  }
]